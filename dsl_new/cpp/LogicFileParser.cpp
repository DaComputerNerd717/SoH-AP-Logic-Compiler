
// Generated from ../cpp/LogicFileParser.g4 by ANTLR 4.13.2


#include "LogicFileParserVisitor.h"

#include "LogicFileParser.h"


using namespace antlrcpp;

using namespace antlr4;

namespace {

struct LogicFileParserStaticData final {
  LogicFileParserStaticData(std::vector<std::string> ruleNames,
                        std::vector<std::string> literalNames,
                        std::vector<std::string> symbolicNames)
      : ruleNames(std::move(ruleNames)), literalNames(std::move(literalNames)),
        symbolicNames(std::move(symbolicNames)),
        vocabulary(this->literalNames, this->symbolicNames) {}

  LogicFileParserStaticData(const LogicFileParserStaticData&) = delete;
  LogicFileParserStaticData(LogicFileParserStaticData&&) = delete;
  LogicFileParserStaticData& operator=(const LogicFileParserStaticData&) = delete;
  LogicFileParserStaticData& operator=(LogicFileParserStaticData&&) = delete;

  std::vector<antlr4::dfa::DFA> decisionToDFA;
  antlr4::atn::PredictionContextCache sharedContextCache;
  const std::vector<std::string> ruleNames;
  const std::vector<std::string> literalNames;
  const std::vector<std::string> symbolicNames;
  const antlr4::dfa::Vocabulary vocabulary;
  antlr4::atn::SerializedATNView serializedATN;
  std::unique_ptr<antlr4::atn::ATN> atn;
};

::antlr4::internal::OnceFlag logicfileparserParserOnceFlag;
#if ANTLR4_USE_THREAD_LOCAL_CACHE
static thread_local
#endif
std::unique_ptr<LogicFileParserStaticData> logicfileparserParserStaticData = nullptr;

void logicfileparserParserInitialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  if (logicfileparserParserStaticData != nullptr) {
    return;
  }
#else
  assert(logicfileparserParserStaticData == nullptr);
#endif
  auto staticData = std::make_unique<LogicFileParserStaticData>(
    std::vector<std::string>{
      "fileDef", "enumDef", "enumVals", "ifBlock", "ifContinuation", "elseIfBlock", 
      "elseBlock", "switchExpr", "return_case", "caseList", "caseDef", "defaultCase", 
      "args", "arg", "helperDef", "quantityDef", "logicValSet", "nameDef", 
      "classificationDef", "itemDef", "presentWhenDef", "ruleDef", "destDef", 
      "entranceDef", "locationDef", "eventDef", "regionDef", "logicDef", 
      "optionsDef", "optionDefStrings", "optionDefString", "optionDefIntList", 
      "optionDefIntRange", "optionDefInt", "optionDefFloatList", "optionDefFloatRange", 
      "optionDefFloat", "optionDefBool", "expr", "basefunc", "arg_pass", 
      "args_pass", "optionCheck", "helperCall", "argCheck", "logicValCheck", 
      "eventCheck", "canReachLocCall", "canReachEntranceCall", "canReachRegionCall", 
      "hasItemCall", "countItemCall", "isDungeonMqCall", "floorCall", "ceilCall", 
      "value", "parenExpr", "enumValueRef", "entranceRef", "regionRef", 
      "locRef", "itemRef", "listSeparator"
    },
    std::vector<std::string>{
      "", "", "", "", "", "", "", "", "'enum'", "'{'", "'}'", "'('", "')'", 
      "','", "", "", "", "'!='", "'=='", "'>='", "'<='", "'<'", "'>'", "'+'", 
      "'-'", "'*'", "'/'", "'%'", "'>>'", "'<<'", "'\\u003F'", "'='", "'.'", 
      "", "", "", "", "", "", "", "", "", "", "", "'floor'", "'ceil'", "", 
      "", "", "", "'if'", "", "'else'", "'switch'", "'case'", "", "'yields '", 
      "", "", "'helper'", "", "", "", "", "", "'item '", "", "", "", "", 
      "", "'entrance'", "", "'location'", "'event'", "'region'", "'logic'", 
      "'options'", "'option'", "'strings'", "'string'", "'ints'", "'int'", 
      "'floats'", "'float'", "'bool'", "'min'", "'max'", "", "':'"
    },
    std::vector<std::string>{
      "", "Comment", "MLComment", "Bool", "Age", "SignedNumber", "SignedInt", 
      "EscapedString", "EnumDecPrefix", "OBkt", "CBkt", "OPar", "CPar", 
      "Comma", "OrSymbol", "AndSymbol", "NotSymbol", "NeqSymbol", "EqSymbol", 
      "GeqSymbol", "LeqSymbol", "LeSymbol", "GrSymbol", "AddSymbol", "SubSymbol", 
      "MulSymbol", "DivSymbol", "ModSymbol", "RSSymbol", "LSSymbol", "Question", 
      "ArgAssign", "Dot", "OptionCheckKW", "HelperCallKW", "ArgCheckKW", 
      "LogicValCheckKW", "EventCheckKW", "CanReachLocKW", "CanReachEntranceKW", 
      "CanReachRegionKW", "HasItemKW", "CountItemKW", "IsMQDungeonKW", "FloorKW", 
      "CeilKW", "EntranceRefKW", "RegionRefKW", "LocRefKW", "ItemRefKW", 
      "IfPrefix", "ElseIfPrefix", "ElsePrefix", "SwitchPrefix", "SwitchCaseKW", 
      "SwitchDefaultKW", "SwitchReturnsKW", "EOL", "WS", "HelperPrefix", 
      "QuantityPrefix", "LogicValSetPrefix", "NamePrefix", "ClassPrefix", 
      "Classification", "ItemDefPrefix", "PresentWhenPrefix", "RulePrefix", 
      "DestPrefix", "CantCrossChild", "CantCrossAdult", "EntranceDefPrefix", 
      "LocClassDef", "LocationPrefix", "EventDefPrefix", "RegionDefPrefix", 
      "LogicPrefix", "OptionsDefPrefix", "OptionPrefix", "StringsPrefix", 
      "StringPrefix", "IntsPrefix", "IntPrefix", "FloatsPrefix", "FloatPrefix", 
      "BoolPrefix", "MinKW", "MaxKW", "Ident", "Colon"
    }
  );
  static const int32_t serializedATNSegment[] = {
  	4,1,89,1072,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
  	7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,
  	14,2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,
  	21,2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,
  	28,2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,2,33,7,33,2,34,7,34,2,35,7,
  	35,2,36,7,36,2,37,7,37,2,38,7,38,2,39,7,39,2,40,7,40,2,41,7,41,2,42,7,
  	42,2,43,7,43,2,44,7,44,2,45,7,45,2,46,7,46,2,47,7,47,2,48,7,48,2,49,7,
  	49,2,50,7,50,2,51,7,51,2,52,7,52,2,53,7,53,2,54,7,54,2,55,7,55,2,56,7,
  	56,2,57,7,57,2,58,7,58,2,59,7,59,2,60,7,60,2,61,7,61,2,62,7,62,1,0,1,
  	0,1,0,1,0,4,0,131,8,0,11,0,12,0,132,4,0,135,8,0,11,0,12,0,136,1,0,1,0,
  	1,1,1,1,1,1,1,1,5,1,145,8,1,10,1,12,1,148,9,1,1,1,1,1,5,1,152,8,1,10,
  	1,12,1,155,9,1,1,1,1,1,5,1,159,8,1,10,1,12,1,162,9,1,1,2,1,2,1,2,1,2,
  	5,2,168,8,2,10,2,12,2,171,9,2,1,3,1,3,1,3,1,3,1,3,5,3,178,8,3,10,3,12,
  	3,181,9,3,1,3,1,3,5,3,185,8,3,10,3,12,3,188,9,3,1,3,1,3,5,3,192,8,3,10,
  	3,12,3,195,9,3,1,3,1,3,5,3,199,8,3,10,3,12,3,202,9,3,1,3,3,3,205,8,3,
  	1,4,5,4,208,8,4,10,4,12,4,211,9,4,1,4,1,4,3,4,215,8,4,1,5,1,5,1,5,1,5,
  	1,5,5,5,222,8,5,10,5,12,5,225,9,5,1,5,1,5,5,5,229,8,5,10,5,12,5,232,9,
  	5,1,5,1,5,1,5,5,5,237,8,5,10,5,12,5,240,9,5,1,5,3,5,243,8,5,1,6,1,6,5,
  	6,247,8,6,10,6,12,6,250,9,6,1,6,1,6,5,6,254,8,6,10,6,12,6,257,9,6,1,6,
  	1,6,5,6,261,8,6,10,6,12,6,264,9,6,1,6,1,6,5,6,268,8,6,10,6,12,6,271,9,
  	6,1,7,1,7,1,7,3,7,276,8,7,1,7,5,7,279,8,7,10,7,12,7,282,9,7,1,7,1,7,5,
  	7,286,8,7,10,7,12,7,289,9,7,1,7,1,7,5,7,293,8,7,10,7,12,7,296,9,7,1,7,
  	1,7,5,7,300,8,7,10,7,12,7,303,9,7,1,8,1,8,1,8,1,9,1,9,4,9,310,8,9,11,
  	9,12,9,311,1,10,1,10,1,10,3,10,317,8,10,1,10,1,10,4,10,321,8,10,11,10,
  	12,10,322,1,10,1,10,4,10,327,8,10,11,10,12,10,328,3,10,331,8,10,1,11,
  	1,11,1,11,4,11,336,8,11,11,11,12,11,337,1,11,1,11,4,11,342,8,11,11,11,
  	12,11,343,1,12,1,12,1,12,1,12,5,12,350,8,12,10,12,12,12,353,9,12,5,12,
  	355,8,12,10,12,12,12,358,9,12,3,12,360,8,12,1,13,1,13,1,13,1,13,3,13,
  	366,8,13,3,13,368,8,13,1,14,1,14,1,14,1,14,1,14,1,14,3,14,376,8,14,1,
  	14,5,14,379,8,14,10,14,12,14,382,9,14,1,14,1,14,5,14,386,8,14,10,14,12,
  	14,389,9,14,1,14,1,14,5,14,393,8,14,10,14,12,14,396,9,14,1,14,1,14,5,
  	14,400,8,14,10,14,12,14,403,9,14,1,15,1,15,1,15,1,16,1,16,1,16,1,17,1,
  	17,1,17,1,18,1,18,1,18,1,19,1,19,1,19,3,19,420,8,19,1,19,5,19,423,8,19,
  	10,19,12,19,426,9,19,1,19,1,19,5,19,430,8,19,10,19,12,19,433,9,19,1,19,
  	1,19,1,19,1,19,3,19,439,8,19,1,19,4,19,442,8,19,11,19,12,19,443,4,19,
  	446,8,19,11,19,12,19,447,1,19,5,19,451,8,19,10,19,12,19,454,9,19,1,19,
  	1,19,5,19,458,8,19,10,19,12,19,461,9,19,1,20,1,20,1,20,1,21,1,21,1,21,
  	1,22,1,22,1,22,1,23,1,23,1,23,3,23,475,8,23,1,23,5,23,478,8,23,10,23,
  	12,23,481,9,23,1,23,1,23,5,23,485,8,23,10,23,12,23,488,9,23,1,23,1,23,
  	1,23,1,23,1,23,1,23,3,23,496,8,23,1,23,4,23,499,8,23,11,23,12,23,500,
  	4,23,503,8,23,11,23,12,23,504,1,23,1,23,1,24,1,24,1,24,3,24,512,8,24,
  	1,24,5,24,515,8,24,10,24,12,24,518,9,24,1,24,1,24,5,24,522,8,24,10,24,
  	12,24,525,9,24,1,24,1,24,1,24,1,24,1,24,3,24,532,8,24,1,24,4,24,535,8,
  	24,11,24,12,24,536,4,24,539,8,24,11,24,12,24,540,1,24,1,24,1,25,1,25,
  	3,25,547,8,25,1,25,1,25,1,25,1,26,1,26,1,26,3,26,555,8,26,1,26,5,26,558,
  	8,26,10,26,12,26,561,9,26,1,26,1,26,5,26,565,8,26,10,26,12,26,568,9,26,
  	1,26,1,26,1,26,1,26,1,26,3,26,575,8,26,1,26,4,26,578,8,26,11,26,12,26,
  	579,4,26,582,8,26,11,26,12,26,583,1,26,1,26,1,27,1,27,3,27,590,8,27,1,
  	27,5,27,593,8,27,10,27,12,27,596,9,27,1,27,1,27,5,27,600,8,27,10,27,12,
  	27,603,9,27,1,27,1,27,1,27,3,27,608,8,27,1,27,4,27,611,8,27,11,27,12,
  	27,612,4,27,615,8,27,11,27,12,27,616,1,27,1,27,1,28,1,28,3,28,623,8,28,
  	1,28,5,28,626,8,28,10,28,12,28,629,9,28,1,28,1,28,5,28,633,8,28,10,28,
  	12,28,636,9,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,1,28,3,28,647,
  	8,28,1,28,4,28,650,8,28,11,28,12,28,651,4,28,654,8,28,11,28,12,28,655,
  	1,28,1,28,1,29,1,29,1,29,1,29,3,29,664,8,29,1,29,5,29,667,8,29,10,29,
  	12,29,670,9,29,1,29,1,29,5,29,674,8,29,10,29,12,29,677,9,29,1,29,1,29,
  	1,29,1,29,5,29,683,8,29,10,29,12,29,686,9,29,3,29,688,8,29,1,29,5,29,
  	691,8,29,10,29,12,29,694,9,29,1,29,1,29,1,30,1,30,1,30,1,30,1,31,1,31,
  	1,31,1,31,3,31,706,8,31,1,31,5,31,709,8,31,10,31,12,31,712,9,31,1,31,
  	1,31,5,31,716,8,31,10,31,12,31,719,9,31,1,31,1,31,1,31,1,31,3,31,725,
  	8,31,1,31,5,31,728,8,31,10,31,12,31,731,9,31,1,31,1,31,1,32,1,32,1,32,
  	1,32,3,32,739,8,32,1,32,5,32,742,8,32,10,32,12,32,745,9,32,1,32,1,32,
  	5,32,749,8,32,10,32,12,32,752,9,32,1,32,1,32,1,32,1,32,1,32,1,32,1,32,
  	1,32,5,32,762,8,32,10,32,12,32,765,9,32,1,32,1,32,1,33,1,33,1,33,1,33,
  	1,34,1,34,1,34,1,34,3,34,777,8,34,1,34,5,34,780,8,34,10,34,12,34,783,
  	9,34,1,34,1,34,5,34,787,8,34,10,34,12,34,790,9,34,1,34,1,34,1,34,1,34,
  	5,34,796,8,34,10,34,12,34,799,9,34,3,34,801,8,34,1,34,5,34,804,8,34,10,
  	34,12,34,807,9,34,1,34,1,34,1,35,1,35,1,35,1,35,3,35,815,8,35,1,35,5,
  	35,818,8,35,10,35,12,35,821,9,35,1,35,1,35,5,35,825,8,35,10,35,12,35,
  	828,9,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,35,1,36,1,36,1,36,
  	1,36,1,36,5,36,844,8,36,10,36,12,36,847,9,36,1,36,1,36,1,37,1,37,1,37,
  	1,37,1,38,1,38,1,38,1,38,1,38,1,38,3,38,861,8,38,1,38,1,38,1,38,1,38,
  	1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
  	1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
  	1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,1,38,
  	1,38,1,38,1,38,1,38,1,38,5,38,914,8,38,10,38,12,38,917,9,38,1,39,1,39,
  	1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,1,39,
  	3,39,935,8,39,1,40,1,40,3,40,939,8,40,1,40,1,40,3,40,943,8,40,1,41,1,
  	41,1,41,5,41,948,8,41,10,41,12,41,951,9,41,3,41,953,8,41,1,42,1,42,1,
  	42,1,43,1,43,1,43,1,43,1,43,1,43,1,44,1,44,1,44,1,45,1,45,1,45,1,45,1,
  	46,1,46,1,46,1,47,1,47,1,47,1,47,1,47,3,47,979,8,47,1,47,1,47,1,48,1,
  	48,1,48,1,48,1,48,3,48,988,8,48,1,48,1,48,1,49,1,49,1,49,1,49,1,49,3,
  	49,997,8,49,1,49,1,49,1,50,1,50,1,50,1,50,1,50,3,50,1006,8,50,1,50,1,
  	50,1,51,1,51,1,51,1,51,1,51,1,52,1,52,1,52,1,52,1,52,1,53,1,53,1,53,1,
  	53,1,53,1,54,1,54,1,54,1,54,1,54,1,55,1,55,1,55,1,55,1,55,1,55,1,55,1,
  	55,1,55,3,55,1039,8,55,1,56,1,56,1,56,1,56,1,57,1,57,1,57,1,57,1,58,1,
  	58,1,58,1,59,1,59,1,59,1,60,1,60,1,60,1,61,1,61,1,61,1,62,1,62,3,62,1063,
  	8,62,1,62,4,62,1066,8,62,11,62,12,62,1067,3,62,1070,8,62,1,62,0,1,76,
  	63,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,
  	48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,
  	94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,0,0,1191,
  	0,134,1,0,0,0,2,140,1,0,0,0,4,163,1,0,0,0,6,172,1,0,0,0,8,209,1,0,0,0,
  	10,216,1,0,0,0,12,244,1,0,0,0,14,272,1,0,0,0,16,304,1,0,0,0,18,309,1,
  	0,0,0,20,313,1,0,0,0,22,332,1,0,0,0,24,359,1,0,0,0,26,361,1,0,0,0,28,
  	369,1,0,0,0,30,404,1,0,0,0,32,407,1,0,0,0,34,410,1,0,0,0,36,413,1,0,0,
  	0,38,416,1,0,0,0,40,462,1,0,0,0,42,465,1,0,0,0,44,468,1,0,0,0,46,471,
  	1,0,0,0,48,508,1,0,0,0,50,544,1,0,0,0,52,551,1,0,0,0,54,587,1,0,0,0,56,
  	620,1,0,0,0,58,659,1,0,0,0,60,697,1,0,0,0,62,701,1,0,0,0,64,734,1,0,0,
  	0,66,768,1,0,0,0,68,772,1,0,0,0,70,810,1,0,0,0,72,838,1,0,0,0,74,850,
  	1,0,0,0,76,860,1,0,0,0,78,934,1,0,0,0,80,938,1,0,0,0,82,952,1,0,0,0,84,
  	954,1,0,0,0,86,957,1,0,0,0,88,963,1,0,0,0,90,966,1,0,0,0,92,970,1,0,0,
  	0,94,973,1,0,0,0,96,982,1,0,0,0,98,991,1,0,0,0,100,1000,1,0,0,0,102,1009,
  	1,0,0,0,104,1014,1,0,0,0,106,1019,1,0,0,0,108,1024,1,0,0,0,110,1038,1,
  	0,0,0,112,1040,1,0,0,0,114,1044,1,0,0,0,116,1048,1,0,0,0,118,1051,1,0,
  	0,0,120,1054,1,0,0,0,122,1057,1,0,0,0,124,1069,1,0,0,0,126,135,3,54,27,
  	0,127,135,3,56,28,0,128,135,3,2,1,0,129,131,5,57,0,0,130,129,1,0,0,0,
  	131,132,1,0,0,0,132,130,1,0,0,0,132,133,1,0,0,0,133,135,1,0,0,0,134,126,
  	1,0,0,0,134,127,1,0,0,0,134,128,1,0,0,0,134,130,1,0,0,0,135,136,1,0,0,
  	0,136,134,1,0,0,0,136,137,1,0,0,0,137,138,1,0,0,0,138,139,5,0,0,1,139,
  	1,1,0,0,0,140,141,5,8,0,0,141,142,5,88,0,0,142,146,5,9,0,0,143,145,5,
  	57,0,0,144,143,1,0,0,0,145,148,1,0,0,0,146,144,1,0,0,0,146,147,1,0,0,
  	0,147,149,1,0,0,0,148,146,1,0,0,0,149,153,3,4,2,0,150,152,5,57,0,0,151,
  	150,1,0,0,0,152,155,1,0,0,0,153,151,1,0,0,0,153,154,1,0,0,0,154,156,1,
  	0,0,0,155,153,1,0,0,0,156,160,5,10,0,0,157,159,5,57,0,0,158,157,1,0,0,
  	0,159,162,1,0,0,0,160,158,1,0,0,0,160,161,1,0,0,0,161,3,1,0,0,0,162,160,
  	1,0,0,0,163,169,5,88,0,0,164,165,3,124,62,0,165,166,5,88,0,0,166,168,
  	1,0,0,0,167,164,1,0,0,0,168,171,1,0,0,0,169,167,1,0,0,0,169,170,1,0,0,
  	0,170,5,1,0,0,0,171,169,1,0,0,0,172,173,5,50,0,0,173,174,5,11,0,0,174,
  	175,3,76,38,0,175,179,5,12,0,0,176,178,5,57,0,0,177,176,1,0,0,0,178,181,
  	1,0,0,0,179,177,1,0,0,0,179,180,1,0,0,0,180,182,1,0,0,0,181,179,1,0,0,
  	0,182,186,5,9,0,0,183,185,5,57,0,0,184,183,1,0,0,0,185,188,1,0,0,0,186,
  	184,1,0,0,0,186,187,1,0,0,0,187,189,1,0,0,0,188,186,1,0,0,0,189,193,3,
  	76,38,0,190,192,5,57,0,0,191,190,1,0,0,0,192,195,1,0,0,0,193,191,1,0,
  	0,0,193,194,1,0,0,0,194,196,1,0,0,0,195,193,1,0,0,0,196,200,5,10,0,0,
  	197,199,5,57,0,0,198,197,1,0,0,0,199,202,1,0,0,0,200,198,1,0,0,0,200,
  	201,1,0,0,0,201,204,1,0,0,0,202,200,1,0,0,0,203,205,3,8,4,0,204,203,1,
  	0,0,0,204,205,1,0,0,0,205,7,1,0,0,0,206,208,5,57,0,0,207,206,1,0,0,0,
  	208,211,1,0,0,0,209,207,1,0,0,0,209,210,1,0,0,0,210,214,1,0,0,0,211,209,
  	1,0,0,0,212,215,3,12,6,0,213,215,3,10,5,0,214,212,1,0,0,0,214,213,1,0,
  	0,0,215,9,1,0,0,0,216,217,5,51,0,0,217,218,5,11,0,0,218,219,3,76,38,0,
  	219,223,5,12,0,0,220,222,5,57,0,0,221,220,1,0,0,0,222,225,1,0,0,0,223,
  	221,1,0,0,0,223,224,1,0,0,0,224,226,1,0,0,0,225,223,1,0,0,0,226,230,5,
  	9,0,0,227,229,5,57,0,0,228,227,1,0,0,0,229,232,1,0,0,0,230,228,1,0,0,
  	0,230,231,1,0,0,0,231,233,1,0,0,0,232,230,1,0,0,0,233,234,3,76,38,0,234,
  	238,5,10,0,0,235,237,5,57,0,0,236,235,1,0,0,0,237,240,1,0,0,0,238,236,
  	1,0,0,0,238,239,1,0,0,0,239,242,1,0,0,0,240,238,1,0,0,0,241,243,3,8,4,
  	0,242,241,1,0,0,0,242,243,1,0,0,0,243,11,1,0,0,0,244,248,5,52,0,0,245,
  	247,5,57,0,0,246,245,1,0,0,0,247,250,1,0,0,0,248,246,1,0,0,0,248,249,
  	1,0,0,0,249,251,1,0,0,0,250,248,1,0,0,0,251,255,5,9,0,0,252,254,5,57,
  	0,0,253,252,1,0,0,0,254,257,1,0,0,0,255,253,1,0,0,0,255,256,1,0,0,0,256,
  	258,1,0,0,0,257,255,1,0,0,0,258,262,3,76,38,0,259,261,5,57,0,0,260,259,
  	1,0,0,0,261,264,1,0,0,0,262,260,1,0,0,0,262,263,1,0,0,0,263,265,1,0,0,
  	0,264,262,1,0,0,0,265,269,5,10,0,0,266,268,5,57,0,0,267,266,1,0,0,0,268,
  	271,1,0,0,0,269,267,1,0,0,0,269,270,1,0,0,0,270,13,1,0,0,0,271,269,1,
  	0,0,0,272,273,5,53,0,0,273,275,3,76,38,0,274,276,3,16,8,0,275,274,1,0,
  	0,0,275,276,1,0,0,0,276,280,1,0,0,0,277,279,5,57,0,0,278,277,1,0,0,0,
  	279,282,1,0,0,0,280,278,1,0,0,0,280,281,1,0,0,0,281,283,1,0,0,0,282,280,
  	1,0,0,0,283,287,5,9,0,0,284,286,5,57,0,0,285,284,1,0,0,0,286,289,1,0,
  	0,0,287,285,1,0,0,0,287,288,1,0,0,0,288,290,1,0,0,0,289,287,1,0,0,0,290,
  	294,3,18,9,0,291,293,5,57,0,0,292,291,1,0,0,0,293,296,1,0,0,0,294,292,
  	1,0,0,0,294,295,1,0,0,0,295,297,1,0,0,0,296,294,1,0,0,0,297,301,5,10,
  	0,0,298,300,5,57,0,0,299,298,1,0,0,0,300,303,1,0,0,0,301,299,1,0,0,0,
  	301,302,1,0,0,0,302,15,1,0,0,0,303,301,1,0,0,0,304,305,5,56,0,0,305,306,
  	5,3,0,0,306,17,1,0,0,0,307,310,3,20,10,0,308,310,3,22,11,0,309,307,1,
  	0,0,0,309,308,1,0,0,0,310,311,1,0,0,0,311,309,1,0,0,0,311,312,1,0,0,0,
  	312,19,1,0,0,0,313,316,5,54,0,0,314,317,3,110,55,0,315,317,5,88,0,0,316,
  	314,1,0,0,0,316,315,1,0,0,0,317,318,1,0,0,0,318,320,5,89,0,0,319,321,
  	5,57,0,0,320,319,1,0,0,0,321,322,1,0,0,0,322,320,1,0,0,0,322,323,1,0,
  	0,0,323,330,1,0,0,0,324,326,3,76,38,0,325,327,5,57,0,0,326,325,1,0,0,
  	0,327,328,1,0,0,0,328,326,1,0,0,0,328,329,1,0,0,0,329,331,1,0,0,0,330,
  	324,1,0,0,0,330,331,1,0,0,0,331,21,1,0,0,0,332,333,5,55,0,0,333,335,5,
  	89,0,0,334,336,5,57,0,0,335,334,1,0,0,0,336,337,1,0,0,0,337,335,1,0,0,
  	0,337,338,1,0,0,0,338,339,1,0,0,0,339,341,3,76,38,0,340,342,5,57,0,0,
  	341,340,1,0,0,0,342,343,1,0,0,0,343,341,1,0,0,0,343,344,1,0,0,0,344,23,
  	1,0,0,0,345,356,3,26,13,0,346,347,5,13,0,0,347,351,3,26,13,0,348,350,
  	5,57,0,0,349,348,1,0,0,0,350,353,1,0,0,0,351,349,1,0,0,0,351,352,1,0,
  	0,0,352,355,1,0,0,0,353,351,1,0,0,0,354,346,1,0,0,0,355,358,1,0,0,0,356,
  	354,1,0,0,0,356,357,1,0,0,0,357,360,1,0,0,0,358,356,1,0,0,0,359,345,1,
  	0,0,0,359,360,1,0,0,0,360,25,1,0,0,0,361,367,5,88,0,0,362,365,5,31,0,
  	0,363,366,3,76,38,0,364,366,5,88,0,0,365,363,1,0,0,0,365,364,1,0,0,0,
  	366,368,1,0,0,0,367,362,1,0,0,0,367,368,1,0,0,0,368,27,1,0,0,0,369,370,
  	5,59,0,0,370,371,5,88,0,0,371,372,5,11,0,0,372,373,3,24,12,0,373,375,
  	5,12,0,0,374,376,5,89,0,0,375,374,1,0,0,0,375,376,1,0,0,0,376,380,1,0,
  	0,0,377,379,5,57,0,0,378,377,1,0,0,0,379,382,1,0,0,0,380,378,1,0,0,0,
  	380,381,1,0,0,0,381,383,1,0,0,0,382,380,1,0,0,0,383,387,5,9,0,0,384,386,
  	5,57,0,0,385,384,1,0,0,0,386,389,1,0,0,0,387,385,1,0,0,0,387,388,1,0,
  	0,0,388,390,1,0,0,0,389,387,1,0,0,0,390,394,3,76,38,0,391,393,5,57,0,
  	0,392,391,1,0,0,0,393,396,1,0,0,0,394,392,1,0,0,0,394,395,1,0,0,0,395,
  	397,1,0,0,0,396,394,1,0,0,0,397,401,5,10,0,0,398,400,5,57,0,0,399,398,
  	1,0,0,0,400,403,1,0,0,0,401,399,1,0,0,0,401,402,1,0,0,0,402,29,1,0,0,
  	0,403,401,1,0,0,0,404,405,5,60,0,0,405,406,3,76,38,0,406,31,1,0,0,0,407,
  	408,5,61,0,0,408,409,5,88,0,0,409,33,1,0,0,0,410,411,5,62,0,0,411,412,
  	5,7,0,0,412,35,1,0,0,0,413,414,5,63,0,0,414,415,5,64,0,0,415,37,1,0,0,
  	0,416,417,5,65,0,0,417,419,5,88,0,0,418,420,5,89,0,0,419,418,1,0,0,0,
  	419,420,1,0,0,0,420,424,1,0,0,0,421,423,5,57,0,0,422,421,1,0,0,0,423,
  	426,1,0,0,0,424,422,1,0,0,0,424,425,1,0,0,0,425,427,1,0,0,0,426,424,1,
  	0,0,0,427,431,5,9,0,0,428,430,5,57,0,0,429,428,1,0,0,0,430,433,1,0,0,
  	0,431,429,1,0,0,0,431,432,1,0,0,0,432,445,1,0,0,0,433,431,1,0,0,0,434,
  	439,3,32,16,0,435,439,3,34,17,0,436,439,3,36,18,0,437,439,3,30,15,0,438,
  	434,1,0,0,0,438,435,1,0,0,0,438,436,1,0,0,0,438,437,1,0,0,0,439,441,1,
  	0,0,0,440,442,5,57,0,0,441,440,1,0,0,0,442,443,1,0,0,0,443,441,1,0,0,
  	0,443,444,1,0,0,0,444,446,1,0,0,0,445,438,1,0,0,0,446,447,1,0,0,0,447,
  	445,1,0,0,0,447,448,1,0,0,0,448,452,1,0,0,0,449,451,5,57,0,0,450,449,
  	1,0,0,0,451,454,1,0,0,0,452,450,1,0,0,0,452,453,1,0,0,0,453,455,1,0,0,
  	0,454,452,1,0,0,0,455,459,5,10,0,0,456,458,5,57,0,0,457,456,1,0,0,0,458,
  	461,1,0,0,0,459,457,1,0,0,0,459,460,1,0,0,0,460,39,1,0,0,0,461,459,1,
  	0,0,0,462,463,5,66,0,0,463,464,3,76,38,0,464,41,1,0,0,0,465,466,5,67,
  	0,0,466,467,3,76,38,0,467,43,1,0,0,0,468,469,5,68,0,0,469,470,5,88,0,
  	0,470,45,1,0,0,0,471,472,5,71,0,0,472,474,5,88,0,0,473,475,5,89,0,0,474,
  	473,1,0,0,0,474,475,1,0,0,0,475,479,1,0,0,0,476,478,5,57,0,0,477,476,
  	1,0,0,0,478,481,1,0,0,0,479,477,1,0,0,0,479,480,1,0,0,0,480,482,1,0,0,
  	0,481,479,1,0,0,0,482,486,5,9,0,0,483,485,5,57,0,0,484,483,1,0,0,0,485,
  	488,1,0,0,0,486,484,1,0,0,0,486,487,1,0,0,0,487,502,1,0,0,0,488,486,1,
  	0,0,0,489,496,3,34,17,0,490,496,3,40,20,0,491,496,3,42,21,0,492,496,3,
  	44,22,0,493,496,5,70,0,0,494,496,5,69,0,0,495,489,1,0,0,0,495,490,1,0,
  	0,0,495,491,1,0,0,0,495,492,1,0,0,0,495,493,1,0,0,0,495,494,1,0,0,0,496,
  	498,1,0,0,0,497,499,5,57,0,0,498,497,1,0,0,0,499,500,1,0,0,0,500,498,
  	1,0,0,0,500,501,1,0,0,0,501,503,1,0,0,0,502,495,1,0,0,0,503,504,1,0,0,
  	0,504,502,1,0,0,0,504,505,1,0,0,0,505,506,1,0,0,0,506,507,5,10,0,0,507,
  	47,1,0,0,0,508,509,5,73,0,0,509,511,5,88,0,0,510,512,5,89,0,0,511,510,
  	1,0,0,0,511,512,1,0,0,0,512,516,1,0,0,0,513,515,5,57,0,0,514,513,1,0,
  	0,0,515,518,1,0,0,0,516,514,1,0,0,0,516,517,1,0,0,0,517,519,1,0,0,0,518,
  	516,1,0,0,0,519,523,5,9,0,0,520,522,5,57,0,0,521,520,1,0,0,0,522,525,
  	1,0,0,0,523,521,1,0,0,0,523,524,1,0,0,0,524,538,1,0,0,0,525,523,1,0,0,
  	0,526,532,3,34,17,0,527,532,3,42,21,0,528,532,5,72,0,0,529,532,3,42,21,
  	0,530,532,3,40,20,0,531,526,1,0,0,0,531,527,1,0,0,0,531,528,1,0,0,0,531,
  	529,1,0,0,0,531,530,1,0,0,0,532,534,1,0,0,0,533,535,5,57,0,0,534,533,
  	1,0,0,0,535,536,1,0,0,0,536,534,1,0,0,0,536,537,1,0,0,0,537,539,1,0,0,
  	0,538,531,1,0,0,0,539,540,1,0,0,0,540,538,1,0,0,0,540,541,1,0,0,0,541,
  	542,1,0,0,0,542,543,5,10,0,0,543,49,1,0,0,0,544,546,5,74,0,0,545,547,
  	5,88,0,0,546,545,1,0,0,0,546,547,1,0,0,0,547,548,1,0,0,0,548,549,5,89,
  	0,0,549,550,3,76,38,0,550,51,1,0,0,0,551,552,5,75,0,0,552,554,5,88,0,
  	0,553,555,5,89,0,0,554,553,1,0,0,0,554,555,1,0,0,0,555,559,1,0,0,0,556,
  	558,5,57,0,0,557,556,1,0,0,0,558,561,1,0,0,0,559,557,1,0,0,0,559,560,
  	1,0,0,0,560,562,1,0,0,0,561,559,1,0,0,0,562,566,5,9,0,0,563,565,5,57,
  	0,0,564,563,1,0,0,0,565,568,1,0,0,0,566,564,1,0,0,0,566,567,1,0,0,0,567,
  	581,1,0,0,0,568,566,1,0,0,0,569,575,3,34,17,0,570,575,3,48,24,0,571,575,
  	3,46,23,0,572,575,3,50,25,0,573,575,3,40,20,0,574,569,1,0,0,0,574,570,
  	1,0,0,0,574,571,1,0,0,0,574,572,1,0,0,0,574,573,1,0,0,0,575,577,1,0,0,
  	0,576,578,5,57,0,0,577,576,1,0,0,0,578,579,1,0,0,0,579,577,1,0,0,0,579,
  	580,1,0,0,0,580,582,1,0,0,0,581,574,1,0,0,0,582,583,1,0,0,0,583,581,1,
  	0,0,0,583,584,1,0,0,0,584,585,1,0,0,0,585,586,5,10,0,0,586,53,1,0,0,0,
  	587,589,5,76,0,0,588,590,5,89,0,0,589,588,1,0,0,0,589,590,1,0,0,0,590,
  	594,1,0,0,0,591,593,5,57,0,0,592,591,1,0,0,0,593,596,1,0,0,0,594,592,
  	1,0,0,0,594,595,1,0,0,0,595,597,1,0,0,0,596,594,1,0,0,0,597,601,5,9,0,
  	0,598,600,5,57,0,0,599,598,1,0,0,0,600,603,1,0,0,0,601,599,1,0,0,0,601,
  	602,1,0,0,0,602,614,1,0,0,0,603,601,1,0,0,0,604,608,3,52,26,0,605,608,
  	3,38,19,0,606,608,3,28,14,0,607,604,1,0,0,0,607,605,1,0,0,0,607,606,1,
  	0,0,0,608,610,1,0,0,0,609,611,5,57,0,0,610,609,1,0,0,0,611,612,1,0,0,
  	0,612,610,1,0,0,0,612,613,1,0,0,0,613,615,1,0,0,0,614,607,1,0,0,0,615,
  	616,1,0,0,0,616,614,1,0,0,0,616,617,1,0,0,0,617,618,1,0,0,0,618,619,5,
  	10,0,0,619,55,1,0,0,0,620,622,5,77,0,0,621,623,5,89,0,0,622,621,1,0,0,
  	0,622,623,1,0,0,0,623,627,1,0,0,0,624,626,5,57,0,0,625,624,1,0,0,0,626,
  	629,1,0,0,0,627,625,1,0,0,0,627,628,1,0,0,0,628,630,1,0,0,0,629,627,1,
  	0,0,0,630,634,5,9,0,0,631,633,5,57,0,0,632,631,1,0,0,0,633,636,1,0,0,
  	0,634,632,1,0,0,0,634,635,1,0,0,0,635,653,1,0,0,0,636,634,1,0,0,0,637,
  	647,3,58,29,0,638,647,3,64,32,0,639,647,3,62,31,0,640,647,3,70,35,0,641,
  	647,3,68,34,0,642,647,3,66,33,0,643,647,3,72,36,0,644,647,3,60,30,0,645,
  	647,3,74,37,0,646,637,1,0,0,0,646,638,1,0,0,0,646,639,1,0,0,0,646,640,
  	1,0,0,0,646,641,1,0,0,0,646,642,1,0,0,0,646,643,1,0,0,0,646,644,1,0,0,
  	0,646,645,1,0,0,0,647,649,1,0,0,0,648,650,5,57,0,0,649,648,1,0,0,0,650,
  	651,1,0,0,0,651,649,1,0,0,0,651,652,1,0,0,0,652,654,1,0,0,0,653,646,1,
  	0,0,0,654,655,1,0,0,0,655,653,1,0,0,0,655,656,1,0,0,0,656,657,1,0,0,0,
  	657,658,5,10,0,0,658,57,1,0,0,0,659,660,5,78,0,0,660,661,5,79,0,0,661,
  	663,5,88,0,0,662,664,5,89,0,0,663,662,1,0,0,0,663,664,1,0,0,0,664,668,
  	1,0,0,0,665,667,5,57,0,0,666,665,1,0,0,0,667,670,1,0,0,0,668,666,1,0,
  	0,0,668,669,1,0,0,0,669,671,1,0,0,0,670,668,1,0,0,0,671,675,5,9,0,0,672,
  	674,5,57,0,0,673,672,1,0,0,0,674,677,1,0,0,0,675,673,1,0,0,0,675,676,
  	1,0,0,0,676,687,1,0,0,0,677,675,1,0,0,0,678,684,5,7,0,0,679,680,3,124,
  	62,0,680,681,5,7,0,0,681,683,1,0,0,0,682,679,1,0,0,0,683,686,1,0,0,0,
  	684,682,1,0,0,0,684,685,1,0,0,0,685,688,1,0,0,0,686,684,1,0,0,0,687,678,
  	1,0,0,0,687,688,1,0,0,0,688,692,1,0,0,0,689,691,5,57,0,0,690,689,1,0,
  	0,0,691,694,1,0,0,0,692,690,1,0,0,0,692,693,1,0,0,0,693,695,1,0,0,0,694,
  	692,1,0,0,0,695,696,5,10,0,0,696,59,1,0,0,0,697,698,5,78,0,0,698,699,
  	5,80,0,0,699,700,5,88,0,0,700,61,1,0,0,0,701,702,5,78,0,0,702,703,5,81,
  	0,0,703,705,5,88,0,0,704,706,5,89,0,0,705,704,1,0,0,0,705,706,1,0,0,0,
  	706,710,1,0,0,0,707,709,5,57,0,0,708,707,1,0,0,0,709,712,1,0,0,0,710,
  	708,1,0,0,0,710,711,1,0,0,0,711,713,1,0,0,0,712,710,1,0,0,0,713,717,5,
  	9,0,0,714,716,5,57,0,0,715,714,1,0,0,0,716,719,1,0,0,0,717,715,1,0,0,
  	0,717,718,1,0,0,0,718,724,1,0,0,0,719,717,1,0,0,0,720,721,5,6,0,0,721,
  	722,3,124,62,0,722,723,5,6,0,0,723,725,1,0,0,0,724,720,1,0,0,0,724,725,
  	1,0,0,0,725,729,1,0,0,0,726,728,5,57,0,0,727,726,1,0,0,0,728,731,1,0,
  	0,0,729,727,1,0,0,0,729,730,1,0,0,0,730,732,1,0,0,0,731,729,1,0,0,0,732,
  	733,5,10,0,0,733,63,1,0,0,0,734,735,5,78,0,0,735,736,5,81,0,0,736,738,
  	5,88,0,0,737,739,5,89,0,0,738,737,1,0,0,0,738,739,1,0,0,0,739,743,1,0,
  	0,0,740,742,5,57,0,0,741,740,1,0,0,0,742,745,1,0,0,0,743,741,1,0,0,0,
  	743,744,1,0,0,0,744,746,1,0,0,0,745,743,1,0,0,0,746,750,5,9,0,0,747,749,
  	5,57,0,0,748,747,1,0,0,0,749,752,1,0,0,0,750,748,1,0,0,0,750,751,1,0,
  	0,0,751,753,1,0,0,0,752,750,1,0,0,0,753,754,5,86,0,0,754,755,5,89,0,0,
  	755,756,5,6,0,0,756,757,3,124,62,0,757,758,5,87,0,0,758,759,5,89,0,0,
  	759,763,5,6,0,0,760,762,5,57,0,0,761,760,1,0,0,0,762,765,1,0,0,0,763,
  	761,1,0,0,0,763,764,1,0,0,0,764,766,1,0,0,0,765,763,1,0,0,0,766,767,5,
  	10,0,0,767,65,1,0,0,0,768,769,5,78,0,0,769,770,5,82,0,0,770,771,5,88,
  	0,0,771,67,1,0,0,0,772,773,5,78,0,0,773,774,5,83,0,0,774,776,5,88,0,0,
  	775,777,5,89,0,0,776,775,1,0,0,0,776,777,1,0,0,0,777,781,1,0,0,0,778,
  	780,5,57,0,0,779,778,1,0,0,0,780,783,1,0,0,0,781,779,1,0,0,0,781,782,
  	1,0,0,0,782,784,1,0,0,0,783,781,1,0,0,0,784,788,5,9,0,0,785,787,5,57,
  	0,0,786,785,1,0,0,0,787,790,1,0,0,0,788,786,1,0,0,0,788,789,1,0,0,0,789,
  	800,1,0,0,0,790,788,1,0,0,0,791,797,5,5,0,0,792,793,3,124,62,0,793,794,
  	5,5,0,0,794,796,1,0,0,0,795,792,1,0,0,0,796,799,1,0,0,0,797,795,1,0,0,
  	0,797,798,1,0,0,0,798,801,1,0,0,0,799,797,1,0,0,0,800,791,1,0,0,0,800,
  	801,1,0,0,0,801,805,1,0,0,0,802,804,5,57,0,0,803,802,1,0,0,0,804,807,
  	1,0,0,0,805,803,1,0,0,0,805,806,1,0,0,0,806,808,1,0,0,0,807,805,1,0,0,
  	0,808,809,5,10,0,0,809,69,1,0,0,0,810,811,5,78,0,0,811,812,5,83,0,0,812,
  	814,5,88,0,0,813,815,5,89,0,0,814,813,1,0,0,0,814,815,1,0,0,0,815,819,
  	1,0,0,0,816,818,5,57,0,0,817,816,1,0,0,0,818,821,1,0,0,0,819,817,1,0,
  	0,0,819,820,1,0,0,0,820,822,1,0,0,0,821,819,1,0,0,0,822,826,5,9,0,0,823,
  	825,5,57,0,0,824,823,1,0,0,0,825,828,1,0,0,0,826,824,1,0,0,0,826,827,
  	1,0,0,0,827,829,1,0,0,0,828,826,1,0,0,0,829,830,5,86,0,0,830,831,5,89,
  	0,0,831,832,5,5,0,0,832,833,3,124,62,0,833,834,5,87,0,0,834,835,5,89,
  	0,0,835,836,5,5,0,0,836,837,5,10,0,0,837,71,1,0,0,0,838,839,5,78,0,0,
  	839,840,5,84,0,0,840,841,5,88,0,0,841,845,5,89,0,0,842,844,5,57,0,0,843,
  	842,1,0,0,0,844,847,1,0,0,0,845,843,1,0,0,0,845,846,1,0,0,0,846,848,1,
  	0,0,0,847,845,1,0,0,0,848,849,5,5,0,0,849,73,1,0,0,0,850,851,5,78,0,0,
  	851,852,5,85,0,0,852,853,5,88,0,0,853,75,1,0,0,0,854,855,6,38,-1,0,855,
  	861,3,78,39,0,856,857,5,57,0,0,857,861,3,76,38,18,858,859,5,16,0,0,859,
  	861,3,76,38,17,860,854,1,0,0,0,860,856,1,0,0,0,860,858,1,0,0,0,861,915,
  	1,0,0,0,862,863,10,16,0,0,863,864,5,25,0,0,864,914,3,76,38,17,865,866,
  	10,15,0,0,866,867,5,26,0,0,867,914,3,76,38,16,868,869,10,14,0,0,869,870,
  	5,27,0,0,870,914,3,76,38,15,871,872,10,13,0,0,872,873,5,23,0,0,873,914,
  	3,76,38,14,874,875,10,12,0,0,875,876,5,24,0,0,876,914,3,76,38,13,877,
  	878,10,11,0,0,878,879,5,29,0,0,879,914,3,76,38,12,880,881,10,10,0,0,881,
  	882,5,28,0,0,882,914,3,76,38,11,883,884,10,9,0,0,884,885,5,21,0,0,885,
  	914,3,76,38,10,886,887,10,8,0,0,887,888,5,22,0,0,888,914,3,76,38,9,889,
  	890,10,7,0,0,890,891,5,19,0,0,891,914,3,76,38,8,892,893,10,6,0,0,893,
  	894,5,20,0,0,894,914,3,76,38,7,895,896,10,5,0,0,896,897,5,17,0,0,897,
  	914,3,76,38,6,898,899,10,4,0,0,899,900,5,18,0,0,900,914,3,76,38,5,901,
  	902,10,3,0,0,902,903,5,14,0,0,903,914,3,76,38,4,904,905,10,2,0,0,905,
  	906,5,15,0,0,906,914,3,76,38,3,907,908,10,1,0,0,908,909,5,30,0,0,909,
  	910,3,76,38,0,910,911,5,89,0,0,911,912,3,76,38,1,912,914,1,0,0,0,913,
  	862,1,0,0,0,913,865,1,0,0,0,913,868,1,0,0,0,913,871,1,0,0,0,913,874,1,
  	0,0,0,913,877,1,0,0,0,913,880,1,0,0,0,913,883,1,0,0,0,913,886,1,0,0,0,
  	913,889,1,0,0,0,913,892,1,0,0,0,913,895,1,0,0,0,913,898,1,0,0,0,913,901,
  	1,0,0,0,913,904,1,0,0,0,913,907,1,0,0,0,914,917,1,0,0,0,915,913,1,0,0,
  	0,915,916,1,0,0,0,916,77,1,0,0,0,917,915,1,0,0,0,918,935,3,84,42,0,919,
  	935,3,86,43,0,920,935,3,88,44,0,921,935,3,90,45,0,922,935,3,92,46,0,923,
  	935,3,94,47,0,924,935,3,96,48,0,925,935,3,98,49,0,926,935,3,100,50,0,
  	927,935,3,102,51,0,928,935,3,104,52,0,929,935,3,106,53,0,930,935,3,108,
  	54,0,931,935,3,14,7,0,932,935,3,6,3,0,933,935,3,110,55,0,934,918,1,0,
  	0,0,934,919,1,0,0,0,934,920,1,0,0,0,934,921,1,0,0,0,934,922,1,0,0,0,934,
  	923,1,0,0,0,934,924,1,0,0,0,934,925,1,0,0,0,934,926,1,0,0,0,934,927,1,
  	0,0,0,934,928,1,0,0,0,934,929,1,0,0,0,934,930,1,0,0,0,934,931,1,0,0,0,
  	934,932,1,0,0,0,934,933,1,0,0,0,935,79,1,0,0,0,936,937,5,88,0,0,937,939,
  	5,31,0,0,938,936,1,0,0,0,938,939,1,0,0,0,939,942,1,0,0,0,940,943,3,76,
  	38,0,941,943,5,88,0,0,942,940,1,0,0,0,942,941,1,0,0,0,943,81,1,0,0,0,
  	944,949,3,80,40,0,945,946,5,13,0,0,946,948,3,80,40,0,947,945,1,0,0,0,
  	948,951,1,0,0,0,949,947,1,0,0,0,949,950,1,0,0,0,950,953,1,0,0,0,951,949,
  	1,0,0,0,952,944,1,0,0,0,952,953,1,0,0,0,953,83,1,0,0,0,954,955,5,33,0,
  	0,955,956,5,88,0,0,956,85,1,0,0,0,957,958,5,34,0,0,958,959,5,88,0,0,959,
  	960,5,11,0,0,960,961,3,82,41,0,961,962,5,12,0,0,962,87,1,0,0,0,963,964,
  	5,35,0,0,964,965,5,88,0,0,965,89,1,0,0,0,966,967,5,36,0,0,967,968,5,32,
  	0,0,968,969,5,88,0,0,969,91,1,0,0,0,970,971,5,37,0,0,971,972,5,88,0,0,
  	972,93,1,0,0,0,973,974,5,38,0,0,974,975,5,11,0,0,975,978,5,88,0,0,976,
  	977,5,13,0,0,977,979,5,4,0,0,978,976,1,0,0,0,978,979,1,0,0,0,979,980,
  	1,0,0,0,980,981,5,12,0,0,981,95,1,0,0,0,982,983,5,39,0,0,983,984,5,11,
  	0,0,984,987,5,88,0,0,985,986,5,13,0,0,986,988,5,4,0,0,987,985,1,0,0,0,
  	987,988,1,0,0,0,988,989,1,0,0,0,989,990,5,12,0,0,990,97,1,0,0,0,991,992,
  	5,40,0,0,992,993,5,11,0,0,993,996,5,88,0,0,994,995,5,13,0,0,995,997,5,
  	4,0,0,996,994,1,0,0,0,996,997,1,0,0,0,997,998,1,0,0,0,998,999,5,12,0,
  	0,999,99,1,0,0,0,1000,1001,5,41,0,0,1001,1002,5,11,0,0,1002,1005,5,88,
  	0,0,1003,1004,5,13,0,0,1004,1006,3,76,38,0,1005,1003,1,0,0,0,1005,1006,
  	1,0,0,0,1006,1007,1,0,0,0,1007,1008,5,12,0,0,1008,101,1,0,0,0,1009,1010,
  	5,42,0,0,1010,1011,5,11,0,0,1011,1012,5,88,0,0,1012,1013,5,12,0,0,1013,
  	103,1,0,0,0,1014,1015,5,43,0,0,1015,1016,5,11,0,0,1016,1017,5,88,0,0,
  	1017,1018,5,12,0,0,1018,105,1,0,0,0,1019,1020,5,44,0,0,1020,1021,5,11,
  	0,0,1021,1022,3,76,38,0,1022,1023,5,12,0,0,1023,107,1,0,0,0,1024,1025,
  	5,45,0,0,1025,1026,5,11,0,0,1026,1027,3,76,38,0,1027,1028,5,12,0,0,1028,
  	109,1,0,0,0,1029,1039,3,112,56,0,1030,1039,5,3,0,0,1031,1039,5,5,0,0,
  	1032,1039,3,114,57,0,1033,1039,3,116,58,0,1034,1039,3,118,59,0,1035,1039,
  	3,120,60,0,1036,1039,3,122,61,0,1037,1039,5,7,0,0,1038,1029,1,0,0,0,1038,
  	1030,1,0,0,0,1038,1031,1,0,0,0,1038,1032,1,0,0,0,1038,1033,1,0,0,0,1038,
  	1034,1,0,0,0,1038,1035,1,0,0,0,1038,1036,1,0,0,0,1038,1037,1,0,0,0,1039,
  	111,1,0,0,0,1040,1041,5,11,0,0,1041,1042,3,76,38,0,1042,1043,5,12,0,0,
  	1043,113,1,0,0,0,1044,1045,5,88,0,0,1045,1046,5,89,0,0,1046,1047,5,88,
  	0,0,1047,115,1,0,0,0,1048,1049,5,46,0,0,1049,1050,5,88,0,0,1050,117,1,
  	0,0,0,1051,1052,5,47,0,0,1052,1053,5,88,0,0,1053,119,1,0,0,0,1054,1055,
  	5,48,0,0,1055,1056,5,88,0,0,1056,121,1,0,0,0,1057,1058,5,49,0,0,1058,
  	1059,5,88,0,0,1059,123,1,0,0,0,1060,1070,5,13,0,0,1061,1063,5,13,0,0,
  	1062,1061,1,0,0,0,1062,1063,1,0,0,0,1063,1065,1,0,0,0,1064,1066,5,57,
  	0,0,1065,1064,1,0,0,0,1066,1067,1,0,0,0,1067,1065,1,0,0,0,1067,1068,1,
  	0,0,0,1068,1070,1,0,0,0,1069,1060,1,0,0,0,1069,1062,1,0,0,0,1070,125,
  	1,0,0,0,125,132,134,136,146,153,160,169,179,186,193,200,204,209,214,223,
  	230,238,242,248,255,262,269,275,280,287,294,301,309,311,316,322,328,330,
  	337,343,351,356,359,365,367,375,380,387,394,401,419,424,431,438,443,447,
  	452,459,474,479,486,495,500,504,511,516,523,531,536,540,546,554,559,566,
  	574,579,583,589,594,601,607,612,616,622,627,634,646,651,655,663,668,675,
  	684,687,692,705,710,717,724,729,738,743,750,763,776,781,788,797,800,805,
  	814,819,826,845,860,913,915,934,938,942,949,952,978,987,996,1005,1038,
  	1062,1067,1069
  };
  staticData->serializedATN = antlr4::atn::SerializedATNView(serializedATNSegment, sizeof(serializedATNSegment) / sizeof(serializedATNSegment[0]));

  antlr4::atn::ATNDeserializer deserializer;
  staticData->atn = deserializer.deserialize(staticData->serializedATN);

  const size_t count = staticData->atn->getNumberOfDecisions();
  staticData->decisionToDFA.reserve(count);
  for (size_t i = 0; i < count; i++) { 
    staticData->decisionToDFA.emplace_back(staticData->atn->getDecisionState(i), i);
  }
  logicfileparserParserStaticData = std::move(staticData);
}

}

LogicFileParser::LogicFileParser(TokenStream *input) : LogicFileParser(input, antlr4::atn::ParserATNSimulatorOptions()) {}

LogicFileParser::LogicFileParser(TokenStream *input, const antlr4::atn::ParserATNSimulatorOptions &options) : Parser(input) {
  LogicFileParser::initialize();
  _interpreter = new atn::ParserATNSimulator(this, *logicfileparserParserStaticData->atn, logicfileparserParserStaticData->decisionToDFA, logicfileparserParserStaticData->sharedContextCache, options);
}

LogicFileParser::~LogicFileParser() {
  delete _interpreter;
}

const atn::ATN& LogicFileParser::getATN() const {
  return *logicfileparserParserStaticData->atn;
}

std::string LogicFileParser::getGrammarFileName() const {
  return "LogicFileParser.g4";
}

const std::vector<std::string>& LogicFileParser::getRuleNames() const {
  return logicfileparserParserStaticData->ruleNames;
}

const dfa::Vocabulary& LogicFileParser::getVocabulary() const {
  return logicfileparserParserStaticData->vocabulary;
}

antlr4::atn::SerializedATNView LogicFileParser::getSerializedATN() const {
  return logicfileparserParserStaticData->serializedATN;
}


//----------------- FileDefContext ------------------------------------------------------------------

LogicFileParser::FileDefContext::FileDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::FileDefContext::EOF() {
  return getToken(LogicFileParser::EOF, 0);
}

std::vector<LogicFileParser::LogicDefContext *> LogicFileParser::FileDefContext::logicDef() {
  return getRuleContexts<LogicFileParser::LogicDefContext>();
}

LogicFileParser::LogicDefContext* LogicFileParser::FileDefContext::logicDef(size_t i) {
  return getRuleContext<LogicFileParser::LogicDefContext>(i);
}

std::vector<LogicFileParser::OptionsDefContext *> LogicFileParser::FileDefContext::optionsDef() {
  return getRuleContexts<LogicFileParser::OptionsDefContext>();
}

LogicFileParser::OptionsDefContext* LogicFileParser::FileDefContext::optionsDef(size_t i) {
  return getRuleContext<LogicFileParser::OptionsDefContext>(i);
}

std::vector<LogicFileParser::EnumDefContext *> LogicFileParser::FileDefContext::enumDef() {
  return getRuleContexts<LogicFileParser::EnumDefContext>();
}

LogicFileParser::EnumDefContext* LogicFileParser::FileDefContext::enumDef(size_t i) {
  return getRuleContext<LogicFileParser::EnumDefContext>(i);
}

std::vector<tree::TerminalNode *> LogicFileParser::FileDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::FileDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::FileDefContext::getRuleIndex() const {
  return LogicFileParser::RuleFileDef;
}


std::any LogicFileParser::FileDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitFileDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::FileDefContext* LogicFileParser::fileDef() {
  FileDefContext *_localctx = _tracker.createInstance<FileDefContext>(_ctx, getState());
  enterRule(_localctx, 0, LogicFileParser::RuleFileDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(134); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(134);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LogicFileParser::LogicPrefix: {
          setState(126);
          logicDef();
          break;
        }

        case LogicFileParser::OptionsDefPrefix: {
          setState(127);
          optionsDef();
          break;
        }

        case LogicFileParser::EnumDecPrefix: {
          setState(128);
          enumDef();
          break;
        }

        case LogicFileParser::EOL: {
          setState(130); 
          _errHandler->sync(this);
          alt = 1;
          do {
            switch (alt) {
              case 1: {
                    setState(129);
                    match(LogicFileParser::EOL);
                    break;
                  }

            default:
              throw NoViableAltException(this);
            }
            setState(132); 
            _errHandler->sync(this);
            alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 0, _ctx);
          } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(136); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LogicFileParser::EnumDecPrefix

    || _la == LogicFileParser::EOL || _la == LogicFileParser::LogicPrefix

    || _la == LogicFileParser::OptionsDefPrefix);
    setState(138);
    match(LogicFileParser::EOF);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumDefContext ------------------------------------------------------------------

LogicFileParser::EnumDefContext::EnumDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::EnumDefContext::EnumDecPrefix() {
  return getToken(LogicFileParser::EnumDecPrefix, 0);
}

tree::TerminalNode* LogicFileParser::EnumDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::EnumDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

LogicFileParser::EnumValsContext* LogicFileParser::EnumDefContext::enumVals() {
  return getRuleContext<LogicFileParser::EnumValsContext>(0);
}

tree::TerminalNode* LogicFileParser::EnumDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::EnumDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::EnumDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::EnumDefContext::getRuleIndex() const {
  return LogicFileParser::RuleEnumDef;
}


std::any LogicFileParser::EnumDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEnumDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::EnumDefContext* LogicFileParser::enumDef() {
  EnumDefContext *_localctx = _tracker.createInstance<EnumDefContext>(_ctx, getState());
  enterRule(_localctx, 2, LogicFileParser::RuleEnumDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(140);
    match(LogicFileParser::EnumDecPrefix);
    setState(141);
    match(LogicFileParser::Ident);
    setState(142);
    match(LogicFileParser::OBkt);
    setState(146);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(143);
      match(LogicFileParser::EOL);
      setState(148);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(149);
    enumVals();
    setState(153);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(150);
      match(LogicFileParser::EOL);
      setState(155);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(156);
    match(LogicFileParser::CBkt);
    setState(160);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(157);
        match(LogicFileParser::EOL); 
      }
      setState(162);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 5, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumValsContext ------------------------------------------------------------------

LogicFileParser::EnumValsContext::EnumValsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LogicFileParser::EnumValsContext::Ident() {
  return getTokens(LogicFileParser::Ident);
}

tree::TerminalNode* LogicFileParser::EnumValsContext::Ident(size_t i) {
  return getToken(LogicFileParser::Ident, i);
}

std::vector<LogicFileParser::ListSeparatorContext *> LogicFileParser::EnumValsContext::listSeparator() {
  return getRuleContexts<LogicFileParser::ListSeparatorContext>();
}

LogicFileParser::ListSeparatorContext* LogicFileParser::EnumValsContext::listSeparator(size_t i) {
  return getRuleContext<LogicFileParser::ListSeparatorContext>(i);
}


size_t LogicFileParser::EnumValsContext::getRuleIndex() const {
  return LogicFileParser::RuleEnumVals;
}


std::any LogicFileParser::EnumValsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEnumVals(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::EnumValsContext* LogicFileParser::enumVals() {
  EnumValsContext *_localctx = _tracker.createInstance<EnumValsContext>(_ctx, getState());
  enterRule(_localctx, 4, LogicFileParser::RuleEnumVals);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(163);
    match(LogicFileParser::Ident);
    setState(169);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(164);
        listSeparator();
        setState(165);
        match(LogicFileParser::Ident); 
      }
      setState(171);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 6, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfBlockContext ------------------------------------------------------------------

LogicFileParser::IfBlockContext::IfBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::IfBlockContext::IfPrefix() {
  return getToken(LogicFileParser::IfPrefix, 0);
}

tree::TerminalNode* LogicFileParser::IfBlockContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

std::vector<LogicFileParser::ExprContext *> LogicFileParser::IfBlockContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::IfBlockContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::IfBlockContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}

tree::TerminalNode* LogicFileParser::IfBlockContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::IfBlockContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::IfBlockContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::IfBlockContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

LogicFileParser::IfContinuationContext* LogicFileParser::IfBlockContext::ifContinuation() {
  return getRuleContext<LogicFileParser::IfContinuationContext>(0);
}


size_t LogicFileParser::IfBlockContext::getRuleIndex() const {
  return LogicFileParser::RuleIfBlock;
}


std::any LogicFileParser::IfBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitIfBlock(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::IfBlockContext* LogicFileParser::ifBlock() {
  IfBlockContext *_localctx = _tracker.createInstance<IfBlockContext>(_ctx, getState());
  enterRule(_localctx, 6, LogicFileParser::RuleIfBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(172);
    match(LogicFileParser::IfPrefix);
    setState(173);
    match(LogicFileParser::OPar);
    setState(174);
    expr(0);
    setState(175);
    match(LogicFileParser::CPar);
    setState(179);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(176);
      match(LogicFileParser::EOL);
      setState(181);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(182);
    match(LogicFileParser::OBkt);
    setState(186);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(183);
        match(LogicFileParser::EOL); 
      }
      setState(188);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 8, _ctx);
    }
    setState(189);
    expr(0);
    setState(193);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(190);
      match(LogicFileParser::EOL);
      setState(195);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(196);
    match(LogicFileParser::CBkt);
    setState(200);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(197);
        match(LogicFileParser::EOL); 
      }
      setState(202);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 10, _ctx);
    }
    setState(204);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 11, _ctx)) {
    case 1: {
      setState(203);
      ifContinuation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IfContinuationContext ------------------------------------------------------------------

LogicFileParser::IfContinuationContext::IfContinuationContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LogicFileParser::ElseBlockContext* LogicFileParser::IfContinuationContext::elseBlock() {
  return getRuleContext<LogicFileParser::ElseBlockContext>(0);
}

LogicFileParser::ElseIfBlockContext* LogicFileParser::IfContinuationContext::elseIfBlock() {
  return getRuleContext<LogicFileParser::ElseIfBlockContext>(0);
}

std::vector<tree::TerminalNode *> LogicFileParser::IfContinuationContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::IfContinuationContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::IfContinuationContext::getRuleIndex() const {
  return LogicFileParser::RuleIfContinuation;
}


std::any LogicFileParser::IfContinuationContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitIfContinuation(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::IfContinuationContext* LogicFileParser::ifContinuation() {
  IfContinuationContext *_localctx = _tracker.createInstance<IfContinuationContext>(_ctx, getState());
  enterRule(_localctx, 8, LogicFileParser::RuleIfContinuation);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(209);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(206);
      match(LogicFileParser::EOL);
      setState(211);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(214);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LogicFileParser::ElsePrefix: {
        setState(212);
        elseBlock();
        break;
      }

      case LogicFileParser::ElseIfPrefix: {
        setState(213);
        elseIfBlock();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseIfBlockContext ------------------------------------------------------------------

LogicFileParser::ElseIfBlockContext::ElseIfBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ElseIfBlockContext::ElseIfPrefix() {
  return getToken(LogicFileParser::ElseIfPrefix, 0);
}

tree::TerminalNode* LogicFileParser::ElseIfBlockContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

std::vector<LogicFileParser::ExprContext *> LogicFileParser::ElseIfBlockContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::ElseIfBlockContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::ElseIfBlockContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}

tree::TerminalNode* LogicFileParser::ElseIfBlockContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::ElseIfBlockContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::ElseIfBlockContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::ElseIfBlockContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

LogicFileParser::IfContinuationContext* LogicFileParser::ElseIfBlockContext::ifContinuation() {
  return getRuleContext<LogicFileParser::IfContinuationContext>(0);
}


size_t LogicFileParser::ElseIfBlockContext::getRuleIndex() const {
  return LogicFileParser::RuleElseIfBlock;
}


std::any LogicFileParser::ElseIfBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitElseIfBlock(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ElseIfBlockContext* LogicFileParser::elseIfBlock() {
  ElseIfBlockContext *_localctx = _tracker.createInstance<ElseIfBlockContext>(_ctx, getState());
  enterRule(_localctx, 10, LogicFileParser::RuleElseIfBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(216);
    match(LogicFileParser::ElseIfPrefix);
    setState(217);
    match(LogicFileParser::OPar);
    setState(218);
    expr(0);
    setState(219);
    match(LogicFileParser::CPar);
    setState(223);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(220);
      match(LogicFileParser::EOL);
      setState(225);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(226);
    match(LogicFileParser::OBkt);
    setState(230);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(227);
        match(LogicFileParser::EOL); 
      }
      setState(232);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 15, _ctx);
    }
    setState(233);
    expr(0);
    setState(234);
    match(LogicFileParser::CBkt);
    setState(238);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(235);
        match(LogicFileParser::EOL); 
      }
      setState(240);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 16, _ctx);
    }
    setState(242);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 17, _ctx)) {
    case 1: {
      setState(241);
      ifContinuation();
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ElseBlockContext ------------------------------------------------------------------

LogicFileParser::ElseBlockContext::ElseBlockContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ElseBlockContext::ElsePrefix() {
  return getToken(LogicFileParser::ElsePrefix, 0);
}

tree::TerminalNode* LogicFileParser::ElseBlockContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

LogicFileParser::ExprContext* LogicFileParser::ElseBlockContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::ElseBlockContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::ElseBlockContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::ElseBlockContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::ElseBlockContext::getRuleIndex() const {
  return LogicFileParser::RuleElseBlock;
}


std::any LogicFileParser::ElseBlockContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitElseBlock(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ElseBlockContext* LogicFileParser::elseBlock() {
  ElseBlockContext *_localctx = _tracker.createInstance<ElseBlockContext>(_ctx, getState());
  enterRule(_localctx, 12, LogicFileParser::RuleElseBlock);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(244);
    match(LogicFileParser::ElsePrefix);
    setState(248);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(245);
      match(LogicFileParser::EOL);
      setState(250);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(251);
    match(LogicFileParser::OBkt);
    setState(255);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(252);
        match(LogicFileParser::EOL); 
      }
      setState(257);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 19, _ctx);
    }
    setState(258);
    expr(0);
    setState(262);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(259);
      match(LogicFileParser::EOL);
      setState(264);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(265);
    match(LogicFileParser::CBkt);
    setState(269);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(266);
        match(LogicFileParser::EOL); 
      }
      setState(271);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 21, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- SwitchExprContext ------------------------------------------------------------------

LogicFileParser::SwitchExprContext::SwitchExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::SwitchExprContext::SwitchPrefix() {
  return getToken(LogicFileParser::SwitchPrefix, 0);
}

LogicFileParser::ExprContext* LogicFileParser::SwitchExprContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::SwitchExprContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

LogicFileParser::CaseListContext* LogicFileParser::SwitchExprContext::caseList() {
  return getRuleContext<LogicFileParser::CaseListContext>(0);
}

tree::TerminalNode* LogicFileParser::SwitchExprContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

LogicFileParser::Return_caseContext* LogicFileParser::SwitchExprContext::return_case() {
  return getRuleContext<LogicFileParser::Return_caseContext>(0);
}

std::vector<tree::TerminalNode *> LogicFileParser::SwitchExprContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::SwitchExprContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::SwitchExprContext::getRuleIndex() const {
  return LogicFileParser::RuleSwitchExpr;
}


std::any LogicFileParser::SwitchExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitSwitchExpr(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::SwitchExprContext* LogicFileParser::switchExpr() {
  SwitchExprContext *_localctx = _tracker.createInstance<SwitchExprContext>(_ctx, getState());
  enterRule(_localctx, 14, LogicFileParser::RuleSwitchExpr);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(272);
    match(LogicFileParser::SwitchPrefix);
    setState(273);
    expr(0);
    setState(275);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::SwitchReturnsKW) {
      setState(274);
      return_case();
    }
    setState(280);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(277);
      match(LogicFileParser::EOL);
      setState(282);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(283);
    match(LogicFileParser::OBkt);
    setState(287);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(284);
      match(LogicFileParser::EOL);
      setState(289);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(290);
    caseList();
    setState(294);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(291);
      match(LogicFileParser::EOL);
      setState(296);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(297);
    match(LogicFileParser::CBkt);
    setState(301);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(298);
        match(LogicFileParser::EOL); 
      }
      setState(303);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 26, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Return_caseContext ------------------------------------------------------------------

LogicFileParser::Return_caseContext::Return_caseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::Return_caseContext::SwitchReturnsKW() {
  return getToken(LogicFileParser::SwitchReturnsKW, 0);
}

tree::TerminalNode* LogicFileParser::Return_caseContext::Bool() {
  return getToken(LogicFileParser::Bool, 0);
}


size_t LogicFileParser::Return_caseContext::getRuleIndex() const {
  return LogicFileParser::RuleReturn_case;
}


std::any LogicFileParser::Return_caseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitReturn_case(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::Return_caseContext* LogicFileParser::return_case() {
  Return_caseContext *_localctx = _tracker.createInstance<Return_caseContext>(_ctx, getState());
  enterRule(_localctx, 16, LogicFileParser::RuleReturn_case);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(304);
    match(LogicFileParser::SwitchReturnsKW);
    setState(305);
    match(LogicFileParser::Bool);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseListContext ------------------------------------------------------------------

LogicFileParser::CaseListContext::CaseListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LogicFileParser::CaseDefContext *> LogicFileParser::CaseListContext::caseDef() {
  return getRuleContexts<LogicFileParser::CaseDefContext>();
}

LogicFileParser::CaseDefContext* LogicFileParser::CaseListContext::caseDef(size_t i) {
  return getRuleContext<LogicFileParser::CaseDefContext>(i);
}

std::vector<LogicFileParser::DefaultCaseContext *> LogicFileParser::CaseListContext::defaultCase() {
  return getRuleContexts<LogicFileParser::DefaultCaseContext>();
}

LogicFileParser::DefaultCaseContext* LogicFileParser::CaseListContext::defaultCase(size_t i) {
  return getRuleContext<LogicFileParser::DefaultCaseContext>(i);
}


size_t LogicFileParser::CaseListContext::getRuleIndex() const {
  return LogicFileParser::RuleCaseList;
}


std::any LogicFileParser::CaseListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitCaseList(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::CaseListContext* LogicFileParser::caseList() {
  CaseListContext *_localctx = _tracker.createInstance<CaseListContext>(_ctx, getState());
  enterRule(_localctx, 18, LogicFileParser::RuleCaseList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(309); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(309);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LogicFileParser::SwitchCaseKW: {
          setState(307);
          caseDef();
          break;
        }

        case LogicFileParser::SwitchDefaultKW: {
          setState(308);
          defaultCase();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(311); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LogicFileParser::SwitchCaseKW

    || _la == LogicFileParser::SwitchDefaultKW);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CaseDefContext ------------------------------------------------------------------

LogicFileParser::CaseDefContext::CaseDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::CaseDefContext::SwitchCaseKW() {
  return getToken(LogicFileParser::SwitchCaseKW, 0);
}

tree::TerminalNode* LogicFileParser::CaseDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

LogicFileParser::ValueContext* LogicFileParser::CaseDefContext::value() {
  return getRuleContext<LogicFileParser::ValueContext>(0);
}

tree::TerminalNode* LogicFileParser::CaseDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::CaseDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::CaseDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

LogicFileParser::ExprContext* LogicFileParser::CaseDefContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}


size_t LogicFileParser::CaseDefContext::getRuleIndex() const {
  return LogicFileParser::RuleCaseDef;
}


std::any LogicFileParser::CaseDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitCaseDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::CaseDefContext* LogicFileParser::caseDef() {
  CaseDefContext *_localctx = _tracker.createInstance<CaseDefContext>(_ctx, getState());
  enterRule(_localctx, 20, LogicFileParser::RuleCaseDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(313);
    match(LogicFileParser::SwitchCaseKW);
    setState(316);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 29, _ctx)) {
    case 1: {
      setState(314);
      value();
      break;
    }

    case 2: {
      setState(315);
      match(LogicFileParser::Ident);
      break;
    }

    default:
      break;
    }
    setState(318);
    match(LogicFileParser::Colon);
    setState(320); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(319);
              match(LogicFileParser::EOL);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(322); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 30, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(330);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 32, _ctx)) {
    case 1: {
      setState(324);
      expr(0);
      setState(326); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(325);
                match(LogicFileParser::EOL);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(328); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 31, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DefaultCaseContext ------------------------------------------------------------------

LogicFileParser::DefaultCaseContext::DefaultCaseContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::DefaultCaseContext::SwitchDefaultKW() {
  return getToken(LogicFileParser::SwitchDefaultKW, 0);
}

tree::TerminalNode* LogicFileParser::DefaultCaseContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

LogicFileParser::ExprContext* LogicFileParser::DefaultCaseContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> LogicFileParser::DefaultCaseContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::DefaultCaseContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::DefaultCaseContext::getRuleIndex() const {
  return LogicFileParser::RuleDefaultCase;
}


std::any LogicFileParser::DefaultCaseContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitDefaultCase(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::DefaultCaseContext* LogicFileParser::defaultCase() {
  DefaultCaseContext *_localctx = _tracker.createInstance<DefaultCaseContext>(_ctx, getState());
  enterRule(_localctx, 22, LogicFileParser::RuleDefaultCase);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(332);
    match(LogicFileParser::SwitchDefaultKW);
    setState(333);
    match(LogicFileParser::Colon);
    setState(335); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(334);
              match(LogicFileParser::EOL);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(337); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 33, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
    setState(339);
    expr(0);
    setState(341); 
    _errHandler->sync(this);
    alt = 1;
    do {
      switch (alt) {
        case 1: {
              setState(340);
              match(LogicFileParser::EOL);
              break;
            }

      default:
        throw NoViableAltException(this);
      }
      setState(343); 
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 34, _ctx);
    } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgsContext ------------------------------------------------------------------

LogicFileParser::ArgsContext::ArgsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LogicFileParser::ArgContext *> LogicFileParser::ArgsContext::arg() {
  return getRuleContexts<LogicFileParser::ArgContext>();
}

LogicFileParser::ArgContext* LogicFileParser::ArgsContext::arg(size_t i) {
  return getRuleContext<LogicFileParser::ArgContext>(i);
}

std::vector<tree::TerminalNode *> LogicFileParser::ArgsContext::Comma() {
  return getTokens(LogicFileParser::Comma);
}

tree::TerminalNode* LogicFileParser::ArgsContext::Comma(size_t i) {
  return getToken(LogicFileParser::Comma, i);
}

std::vector<tree::TerminalNode *> LogicFileParser::ArgsContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::ArgsContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::ArgsContext::getRuleIndex() const {
  return LogicFileParser::RuleArgs;
}


std::any LogicFileParser::ArgsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitArgs(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ArgsContext* LogicFileParser::args() {
  ArgsContext *_localctx = _tracker.createInstance<ArgsContext>(_ctx, getState());
  enterRule(_localctx, 24, LogicFileParser::RuleArgs);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(359);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Ident) {
      setState(345);
      arg();
      setState(356);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LogicFileParser::Comma) {
        setState(346);
        match(LogicFileParser::Comma);
        setState(347);
        arg();
        setState(351);
        _errHandler->sync(this);
        _la = _input->LA(1);
        while (_la == LogicFileParser::EOL) {
          setState(348);
          match(LogicFileParser::EOL);
          setState(353);
          _errHandler->sync(this);
          _la = _input->LA(1);
        }
        setState(358);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgContext ------------------------------------------------------------------

LogicFileParser::ArgContext::ArgContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LogicFileParser::ArgContext::Ident() {
  return getTokens(LogicFileParser::Ident);
}

tree::TerminalNode* LogicFileParser::ArgContext::Ident(size_t i) {
  return getToken(LogicFileParser::Ident, i);
}

tree::TerminalNode* LogicFileParser::ArgContext::ArgAssign() {
  return getToken(LogicFileParser::ArgAssign, 0);
}

LogicFileParser::ExprContext* LogicFileParser::ArgContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}


size_t LogicFileParser::ArgContext::getRuleIndex() const {
  return LogicFileParser::RuleArg;
}


std::any LogicFileParser::ArgContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitArg(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ArgContext* LogicFileParser::arg() {
  ArgContext *_localctx = _tracker.createInstance<ArgContext>(_ctx, getState());
  enterRule(_localctx, 26, LogicFileParser::RuleArg);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(361);
    match(LogicFileParser::Ident);
    setState(367);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::ArgAssign) {
      setState(362);
      match(LogicFileParser::ArgAssign);
      setState(365);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 38, _ctx)) {
      case 1: {
        setState(363);
        expr(0);
        break;
      }

      case 2: {
        setState(364);
        match(LogicFileParser::Ident);
        break;
      }

      default:
        break;
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HelperDefContext ------------------------------------------------------------------

LogicFileParser::HelperDefContext::HelperDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::HelperDefContext::HelperPrefix() {
  return getToken(LogicFileParser::HelperPrefix, 0);
}

tree::TerminalNode* LogicFileParser::HelperDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::HelperDefContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

LogicFileParser::ArgsContext* LogicFileParser::HelperDefContext::args() {
  return getRuleContext<LogicFileParser::ArgsContext>(0);
}

tree::TerminalNode* LogicFileParser::HelperDefContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}

tree::TerminalNode* LogicFileParser::HelperDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

LogicFileParser::ExprContext* LogicFileParser::HelperDefContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::HelperDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::HelperDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::HelperDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::HelperDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::HelperDefContext::getRuleIndex() const {
  return LogicFileParser::RuleHelperDef;
}


std::any LogicFileParser::HelperDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitHelperDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::HelperDefContext* LogicFileParser::helperDef() {
  HelperDefContext *_localctx = _tracker.createInstance<HelperDefContext>(_ctx, getState());
  enterRule(_localctx, 28, LogicFileParser::RuleHelperDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(369);
    match(LogicFileParser::HelperPrefix);
    setState(370);
    match(LogicFileParser::Ident);
    setState(371);
    match(LogicFileParser::OPar);
    setState(372);
    args();
    setState(373);
    match(LogicFileParser::CPar);
    setState(375);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(374);
      match(LogicFileParser::Colon);
    }
    setState(380);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(377);
      match(LogicFileParser::EOL);
      setState(382);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(383);
    match(LogicFileParser::OBkt);
    setState(387);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(384);
        match(LogicFileParser::EOL); 
      }
      setState(389);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 42, _ctx);
    }
    setState(390);
    expr(0);
    setState(394);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(391);
      match(LogicFileParser::EOL);
      setState(396);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(397);
    match(LogicFileParser::CBkt);
    setState(401);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(398);
        match(LogicFileParser::EOL); 
      }
      setState(403);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 44, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- QuantityDefContext ------------------------------------------------------------------

LogicFileParser::QuantityDefContext::QuantityDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::QuantityDefContext::QuantityPrefix() {
  return getToken(LogicFileParser::QuantityPrefix, 0);
}

LogicFileParser::ExprContext* LogicFileParser::QuantityDefContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}


size_t LogicFileParser::QuantityDefContext::getRuleIndex() const {
  return LogicFileParser::RuleQuantityDef;
}


std::any LogicFileParser::QuantityDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitQuantityDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::QuantityDefContext* LogicFileParser::quantityDef() {
  QuantityDefContext *_localctx = _tracker.createInstance<QuantityDefContext>(_ctx, getState());
  enterRule(_localctx, 30, LogicFileParser::RuleQuantityDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(404);
    match(LogicFileParser::QuantityPrefix);
    setState(405);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicValSetContext ------------------------------------------------------------------

LogicFileParser::LogicValSetContext::LogicValSetContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::LogicValSetContext::LogicValSetPrefix() {
  return getToken(LogicFileParser::LogicValSetPrefix, 0);
}

tree::TerminalNode* LogicFileParser::LogicValSetContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::LogicValSetContext::getRuleIndex() const {
  return LogicFileParser::RuleLogicValSet;
}


std::any LogicFileParser::LogicValSetContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLogicValSet(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::LogicValSetContext* LogicFileParser::logicValSet() {
  LogicValSetContext *_localctx = _tracker.createInstance<LogicValSetContext>(_ctx, getState());
  enterRule(_localctx, 32, LogicFileParser::RuleLogicValSet);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(407);
    match(LogicFileParser::LogicValSetPrefix);
    setState(408);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- NameDefContext ------------------------------------------------------------------

LogicFileParser::NameDefContext::NameDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::NameDefContext::NamePrefix() {
  return getToken(LogicFileParser::NamePrefix, 0);
}

tree::TerminalNode* LogicFileParser::NameDefContext::EscapedString() {
  return getToken(LogicFileParser::EscapedString, 0);
}


size_t LogicFileParser::NameDefContext::getRuleIndex() const {
  return LogicFileParser::RuleNameDef;
}


std::any LogicFileParser::NameDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitNameDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::NameDefContext* LogicFileParser::nameDef() {
  NameDefContext *_localctx = _tracker.createInstance<NameDefContext>(_ctx, getState());
  enterRule(_localctx, 34, LogicFileParser::RuleNameDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(410);
    match(LogicFileParser::NamePrefix);
    setState(411);
    match(LogicFileParser::EscapedString);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ClassificationDefContext ------------------------------------------------------------------

LogicFileParser::ClassificationDefContext::ClassificationDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ClassificationDefContext::ClassPrefix() {
  return getToken(LogicFileParser::ClassPrefix, 0);
}

tree::TerminalNode* LogicFileParser::ClassificationDefContext::Classification() {
  return getToken(LogicFileParser::Classification, 0);
}


size_t LogicFileParser::ClassificationDefContext::getRuleIndex() const {
  return LogicFileParser::RuleClassificationDef;
}


std::any LogicFileParser::ClassificationDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitClassificationDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ClassificationDefContext* LogicFileParser::classificationDef() {
  ClassificationDefContext *_localctx = _tracker.createInstance<ClassificationDefContext>(_ctx, getState());
  enterRule(_localctx, 36, LogicFileParser::RuleClassificationDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(413);
    match(LogicFileParser::ClassPrefix);
    setState(414);
    match(LogicFileParser::Classification);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ItemDefContext ------------------------------------------------------------------

LogicFileParser::ItemDefContext::ItemDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ItemDefContext::ItemDefPrefix() {
  return getToken(LogicFileParser::ItemDefPrefix, 0);
}

tree::TerminalNode* LogicFileParser::ItemDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::ItemDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::ItemDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::ItemDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::ItemDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::ItemDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<LogicFileParser::LogicValSetContext *> LogicFileParser::ItemDefContext::logicValSet() {
  return getRuleContexts<LogicFileParser::LogicValSetContext>();
}

LogicFileParser::LogicValSetContext* LogicFileParser::ItemDefContext::logicValSet(size_t i) {
  return getRuleContext<LogicFileParser::LogicValSetContext>(i);
}

std::vector<LogicFileParser::NameDefContext *> LogicFileParser::ItemDefContext::nameDef() {
  return getRuleContexts<LogicFileParser::NameDefContext>();
}

LogicFileParser::NameDefContext* LogicFileParser::ItemDefContext::nameDef(size_t i) {
  return getRuleContext<LogicFileParser::NameDefContext>(i);
}

std::vector<LogicFileParser::ClassificationDefContext *> LogicFileParser::ItemDefContext::classificationDef() {
  return getRuleContexts<LogicFileParser::ClassificationDefContext>();
}

LogicFileParser::ClassificationDefContext* LogicFileParser::ItemDefContext::classificationDef(size_t i) {
  return getRuleContext<LogicFileParser::ClassificationDefContext>(i);
}

std::vector<LogicFileParser::QuantityDefContext *> LogicFileParser::ItemDefContext::quantityDef() {
  return getRuleContexts<LogicFileParser::QuantityDefContext>();
}

LogicFileParser::QuantityDefContext* LogicFileParser::ItemDefContext::quantityDef(size_t i) {
  return getRuleContext<LogicFileParser::QuantityDefContext>(i);
}


size_t LogicFileParser::ItemDefContext::getRuleIndex() const {
  return LogicFileParser::RuleItemDef;
}


std::any LogicFileParser::ItemDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitItemDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ItemDefContext* LogicFileParser::itemDef() {
  ItemDefContext *_localctx = _tracker.createInstance<ItemDefContext>(_ctx, getState());
  enterRule(_localctx, 38, LogicFileParser::RuleItemDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(416);
    match(LogicFileParser::ItemDefPrefix);
    setState(417);
    match(LogicFileParser::Ident);
    setState(419);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(418);
      match(LogicFileParser::Colon);
    }
    setState(424);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(421);
      match(LogicFileParser::EOL);
      setState(426);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(427);
    match(LogicFileParser::OBkt);
    setState(431);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(428);
      match(LogicFileParser::EOL);
      setState(433);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(445); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(438);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LogicFileParser::LogicValSetPrefix: {
          setState(434);
          logicValSet();
          break;
        }

        case LogicFileParser::NamePrefix: {
          setState(435);
          nameDef();
          break;
        }

        case LogicFileParser::ClassPrefix: {
          setState(436);
          classificationDef();
          break;
        }

        case LogicFileParser::QuantityPrefix: {
          setState(437);
          quantityDef();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(441); 
      _errHandler->sync(this);
      alt = 1;
      do {
        switch (alt) {
          case 1: {
                setState(440);
                match(LogicFileParser::EOL);
                break;
              }

        default:
          throw NoViableAltException(this);
        }
        setState(443); 
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 49, _ctx);
      } while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER);
      setState(447); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & -1152921504606846976) != 0));
    setState(452);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(449);
      match(LogicFileParser::EOL);
      setState(454);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(455);
    match(LogicFileParser::CBkt);
    setState(459);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(456);
        match(LogicFileParser::EOL); 
      }
      setState(461);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 52, _ctx);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- PresentWhenDefContext ------------------------------------------------------------------

LogicFileParser::PresentWhenDefContext::PresentWhenDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::PresentWhenDefContext::PresentWhenPrefix() {
  return getToken(LogicFileParser::PresentWhenPrefix, 0);
}

LogicFileParser::ExprContext* LogicFileParser::PresentWhenDefContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}


size_t LogicFileParser::PresentWhenDefContext::getRuleIndex() const {
  return LogicFileParser::RulePresentWhenDef;
}


std::any LogicFileParser::PresentWhenDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitPresentWhenDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::PresentWhenDefContext* LogicFileParser::presentWhenDef() {
  PresentWhenDefContext *_localctx = _tracker.createInstance<PresentWhenDefContext>(_ctx, getState());
  enterRule(_localctx, 40, LogicFileParser::RulePresentWhenDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(462);
    match(LogicFileParser::PresentWhenPrefix);
    setState(463);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RuleDefContext ------------------------------------------------------------------

LogicFileParser::RuleDefContext::RuleDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::RuleDefContext::RulePrefix() {
  return getToken(LogicFileParser::RulePrefix, 0);
}

LogicFileParser::ExprContext* LogicFileParser::RuleDefContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}


size_t LogicFileParser::RuleDefContext::getRuleIndex() const {
  return LogicFileParser::RuleRuleDef;
}


std::any LogicFileParser::RuleDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitRuleDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::RuleDefContext* LogicFileParser::ruleDef() {
  RuleDefContext *_localctx = _tracker.createInstance<RuleDefContext>(_ctx, getState());
  enterRule(_localctx, 42, LogicFileParser::RuleRuleDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(465);
    match(LogicFileParser::RulePrefix);
    setState(466);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- DestDefContext ------------------------------------------------------------------

LogicFileParser::DestDefContext::DestDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::DestDefContext::DestPrefix() {
  return getToken(LogicFileParser::DestPrefix, 0);
}

tree::TerminalNode* LogicFileParser::DestDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::DestDefContext::getRuleIndex() const {
  return LogicFileParser::RuleDestDef;
}


std::any LogicFileParser::DestDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitDestDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::DestDefContext* LogicFileParser::destDef() {
  DestDefContext *_localctx = _tracker.createInstance<DestDefContext>(_ctx, getState());
  enterRule(_localctx, 44, LogicFileParser::RuleDestDef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(468);
    match(LogicFileParser::DestPrefix);
    setState(469);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntranceDefContext ------------------------------------------------------------------

LogicFileParser::EntranceDefContext::EntranceDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::EntranceDefPrefix() {
  return getToken(LogicFileParser::EntranceDefPrefix, 0);
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::EntranceDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<LogicFileParser::NameDefContext *> LogicFileParser::EntranceDefContext::nameDef() {
  return getRuleContexts<LogicFileParser::NameDefContext>();
}

LogicFileParser::NameDefContext* LogicFileParser::EntranceDefContext::nameDef(size_t i) {
  return getRuleContext<LogicFileParser::NameDefContext>(i);
}

std::vector<LogicFileParser::PresentWhenDefContext *> LogicFileParser::EntranceDefContext::presentWhenDef() {
  return getRuleContexts<LogicFileParser::PresentWhenDefContext>();
}

LogicFileParser::PresentWhenDefContext* LogicFileParser::EntranceDefContext::presentWhenDef(size_t i) {
  return getRuleContext<LogicFileParser::PresentWhenDefContext>(i);
}

std::vector<LogicFileParser::RuleDefContext *> LogicFileParser::EntranceDefContext::ruleDef() {
  return getRuleContexts<LogicFileParser::RuleDefContext>();
}

LogicFileParser::RuleDefContext* LogicFileParser::EntranceDefContext::ruleDef(size_t i) {
  return getRuleContext<LogicFileParser::RuleDefContext>(i);
}

std::vector<LogicFileParser::DestDefContext *> LogicFileParser::EntranceDefContext::destDef() {
  return getRuleContexts<LogicFileParser::DestDefContext>();
}

LogicFileParser::DestDefContext* LogicFileParser::EntranceDefContext::destDef(size_t i) {
  return getRuleContext<LogicFileParser::DestDefContext>(i);
}

std::vector<tree::TerminalNode *> LogicFileParser::EntranceDefContext::CantCrossAdult() {
  return getTokens(LogicFileParser::CantCrossAdult);
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::CantCrossAdult(size_t i) {
  return getToken(LogicFileParser::CantCrossAdult, i);
}

std::vector<tree::TerminalNode *> LogicFileParser::EntranceDefContext::CantCrossChild() {
  return getTokens(LogicFileParser::CantCrossChild);
}

tree::TerminalNode* LogicFileParser::EntranceDefContext::CantCrossChild(size_t i) {
  return getToken(LogicFileParser::CantCrossChild, i);
}


size_t LogicFileParser::EntranceDefContext::getRuleIndex() const {
  return LogicFileParser::RuleEntranceDef;
}


std::any LogicFileParser::EntranceDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEntranceDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::EntranceDefContext* LogicFileParser::entranceDef() {
  EntranceDefContext *_localctx = _tracker.createInstance<EntranceDefContext>(_ctx, getState());
  enterRule(_localctx, 46, LogicFileParser::RuleEntranceDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(471);
    match(LogicFileParser::EntranceDefPrefix);
    setState(472);
    match(LogicFileParser::Ident);
    setState(474);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(473);
      match(LogicFileParser::Colon);
    }
    setState(479);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(476);
      match(LogicFileParser::EOL);
      setState(481);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(482);
    match(LogicFileParser::OBkt);
    setState(486);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(483);
      match(LogicFileParser::EOL);
      setState(488);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(502); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(495);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LogicFileParser::NamePrefix: {
          setState(489);
          nameDef();
          break;
        }

        case LogicFileParser::PresentWhenPrefix: {
          setState(490);
          presentWhenDef();
          break;
        }

        case LogicFileParser::RulePrefix: {
          setState(491);
          ruleDef();
          break;
        }

        case LogicFileParser::DestPrefix: {
          setState(492);
          destDef();
          break;
        }

        case LogicFileParser::CantCrossAdult: {
          setState(493);
          match(LogicFileParser::CantCrossAdult);
          break;
        }

        case LogicFileParser::CantCrossChild: {
          setState(494);
          match(LogicFileParser::CantCrossChild);
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(498); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(497);
        match(LogicFileParser::EOL);
        setState(500); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LogicFileParser::EOL);
      setState(504); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 62) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 62)) & 497) != 0));
    setState(506);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LocationDefContext ------------------------------------------------------------------

LogicFileParser::LocationDefContext::LocationDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::LocationDefContext::LocationPrefix() {
  return getToken(LogicFileParser::LocationPrefix, 0);
}

tree::TerminalNode* LogicFileParser::LocationDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::LocationDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::LocationDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::LocationDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::LocationDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::LocationDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<LogicFileParser::NameDefContext *> LogicFileParser::LocationDefContext::nameDef() {
  return getRuleContexts<LogicFileParser::NameDefContext>();
}

LogicFileParser::NameDefContext* LogicFileParser::LocationDefContext::nameDef(size_t i) {
  return getRuleContext<LogicFileParser::NameDefContext>(i);
}

std::vector<LogicFileParser::RuleDefContext *> LogicFileParser::LocationDefContext::ruleDef() {
  return getRuleContexts<LogicFileParser::RuleDefContext>();
}

LogicFileParser::RuleDefContext* LogicFileParser::LocationDefContext::ruleDef(size_t i) {
  return getRuleContext<LogicFileParser::RuleDefContext>(i);
}

std::vector<tree::TerminalNode *> LogicFileParser::LocationDefContext::LocClassDef() {
  return getTokens(LogicFileParser::LocClassDef);
}

tree::TerminalNode* LogicFileParser::LocationDefContext::LocClassDef(size_t i) {
  return getToken(LogicFileParser::LocClassDef, i);
}

std::vector<LogicFileParser::PresentWhenDefContext *> LogicFileParser::LocationDefContext::presentWhenDef() {
  return getRuleContexts<LogicFileParser::PresentWhenDefContext>();
}

LogicFileParser::PresentWhenDefContext* LogicFileParser::LocationDefContext::presentWhenDef(size_t i) {
  return getRuleContext<LogicFileParser::PresentWhenDefContext>(i);
}


size_t LogicFileParser::LocationDefContext::getRuleIndex() const {
  return LogicFileParser::RuleLocationDef;
}


std::any LogicFileParser::LocationDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLocationDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::LocationDefContext* LogicFileParser::locationDef() {
  LocationDefContext *_localctx = _tracker.createInstance<LocationDefContext>(_ctx, getState());
  enterRule(_localctx, 48, LogicFileParser::RuleLocationDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(508);
    match(LogicFileParser::LocationPrefix);
    setState(509);
    match(LogicFileParser::Ident);
    setState(511);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(510);
      match(LogicFileParser::Colon);
    }
    setState(516);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(513);
      match(LogicFileParser::EOL);
      setState(518);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(519);
    match(LogicFileParser::OBkt);
    setState(523);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(520);
      match(LogicFileParser::EOL);
      setState(525);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(538); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(531);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 62, _ctx)) {
      case 1: {
        setState(526);
        nameDef();
        break;
      }

      case 2: {
        setState(527);
        ruleDef();
        break;
      }

      case 3: {
        setState(528);
        match(LogicFileParser::LocClassDef);
        break;
      }

      case 4: {
        setState(529);
        ruleDef();
        break;
      }

      case 5: {
        setState(530);
        presentWhenDef();
        break;
      }

      default:
        break;
      }
      setState(534); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(533);
        match(LogicFileParser::EOL);
        setState(536); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LogicFileParser::EOL);
      setState(540); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 62) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 62)) & 1073) != 0));
    setState(542);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventDefContext ------------------------------------------------------------------

LogicFileParser::EventDefContext::EventDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::EventDefContext::EventDefPrefix() {
  return getToken(LogicFileParser::EventDefPrefix, 0);
}

tree::TerminalNode* LogicFileParser::EventDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

LogicFileParser::ExprContext* LogicFileParser::EventDefContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::EventDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::EventDefContext::getRuleIndex() const {
  return LogicFileParser::RuleEventDef;
}


std::any LogicFileParser::EventDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEventDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::EventDefContext* LogicFileParser::eventDef() {
  EventDefContext *_localctx = _tracker.createInstance<EventDefContext>(_ctx, getState());
  enterRule(_localctx, 50, LogicFileParser::RuleEventDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(544);
    match(LogicFileParser::EventDefPrefix);
    setState(546);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Ident) {
      setState(545);
      match(LogicFileParser::Ident);
    }
    setState(548);
    match(LogicFileParser::Colon);
    setState(549);
    expr(0);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegionDefContext ------------------------------------------------------------------

LogicFileParser::RegionDefContext::RegionDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::RegionDefContext::RegionDefPrefix() {
  return getToken(LogicFileParser::RegionDefPrefix, 0);
}

tree::TerminalNode* LogicFileParser::RegionDefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::RegionDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::RegionDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::RegionDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::RegionDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::RegionDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<LogicFileParser::NameDefContext *> LogicFileParser::RegionDefContext::nameDef() {
  return getRuleContexts<LogicFileParser::NameDefContext>();
}

LogicFileParser::NameDefContext* LogicFileParser::RegionDefContext::nameDef(size_t i) {
  return getRuleContext<LogicFileParser::NameDefContext>(i);
}

std::vector<LogicFileParser::LocationDefContext *> LogicFileParser::RegionDefContext::locationDef() {
  return getRuleContexts<LogicFileParser::LocationDefContext>();
}

LogicFileParser::LocationDefContext* LogicFileParser::RegionDefContext::locationDef(size_t i) {
  return getRuleContext<LogicFileParser::LocationDefContext>(i);
}

std::vector<LogicFileParser::EntranceDefContext *> LogicFileParser::RegionDefContext::entranceDef() {
  return getRuleContexts<LogicFileParser::EntranceDefContext>();
}

LogicFileParser::EntranceDefContext* LogicFileParser::RegionDefContext::entranceDef(size_t i) {
  return getRuleContext<LogicFileParser::EntranceDefContext>(i);
}

std::vector<LogicFileParser::EventDefContext *> LogicFileParser::RegionDefContext::eventDef() {
  return getRuleContexts<LogicFileParser::EventDefContext>();
}

LogicFileParser::EventDefContext* LogicFileParser::RegionDefContext::eventDef(size_t i) {
  return getRuleContext<LogicFileParser::EventDefContext>(i);
}

std::vector<LogicFileParser::PresentWhenDefContext *> LogicFileParser::RegionDefContext::presentWhenDef() {
  return getRuleContexts<LogicFileParser::PresentWhenDefContext>();
}

LogicFileParser::PresentWhenDefContext* LogicFileParser::RegionDefContext::presentWhenDef(size_t i) {
  return getRuleContext<LogicFileParser::PresentWhenDefContext>(i);
}


size_t LogicFileParser::RegionDefContext::getRuleIndex() const {
  return LogicFileParser::RuleRegionDef;
}


std::any LogicFileParser::RegionDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitRegionDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::RegionDefContext* LogicFileParser::regionDef() {
  RegionDefContext *_localctx = _tracker.createInstance<RegionDefContext>(_ctx, getState());
  enterRule(_localctx, 52, LogicFileParser::RuleRegionDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(551);
    match(LogicFileParser::RegionDefPrefix);
    setState(552);
    match(LogicFileParser::Ident);
    setState(554);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(553);
      match(LogicFileParser::Colon);
    }
    setState(559);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(556);
      match(LogicFileParser::EOL);
      setState(561);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(562);
    match(LogicFileParser::OBkt);
    setState(566);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(563);
      match(LogicFileParser::EOL);
      setState(568);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(581); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(574);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LogicFileParser::NamePrefix: {
          setState(569);
          nameDef();
          break;
        }

        case LogicFileParser::LocationPrefix: {
          setState(570);
          locationDef();
          break;
        }

        case LogicFileParser::EntranceDefPrefix: {
          setState(571);
          entranceDef();
          break;
        }

        case LogicFileParser::EventDefPrefix: {
          setState(572);
          eventDef();
          break;
        }

        case LogicFileParser::PresentWhenPrefix: {
          setState(573);
          presentWhenDef();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(577); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(576);
        match(LogicFileParser::EOL);
        setState(579); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LogicFileParser::EOL);
      setState(583); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 62) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 62)) & 6673) != 0));
    setState(585);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicDefContext ------------------------------------------------------------------

LogicFileParser::LogicDefContext::LogicDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::LogicDefContext::LogicPrefix() {
  return getToken(LogicFileParser::LogicPrefix, 0);
}

tree::TerminalNode* LogicFileParser::LogicDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::LogicDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::LogicDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::LogicDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::LogicDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<LogicFileParser::RegionDefContext *> LogicFileParser::LogicDefContext::regionDef() {
  return getRuleContexts<LogicFileParser::RegionDefContext>();
}

LogicFileParser::RegionDefContext* LogicFileParser::LogicDefContext::regionDef(size_t i) {
  return getRuleContext<LogicFileParser::RegionDefContext>(i);
}

std::vector<LogicFileParser::ItemDefContext *> LogicFileParser::LogicDefContext::itemDef() {
  return getRuleContexts<LogicFileParser::ItemDefContext>();
}

LogicFileParser::ItemDefContext* LogicFileParser::LogicDefContext::itemDef(size_t i) {
  return getRuleContext<LogicFileParser::ItemDefContext>(i);
}

std::vector<LogicFileParser::HelperDefContext *> LogicFileParser::LogicDefContext::helperDef() {
  return getRuleContexts<LogicFileParser::HelperDefContext>();
}

LogicFileParser::HelperDefContext* LogicFileParser::LogicDefContext::helperDef(size_t i) {
  return getRuleContext<LogicFileParser::HelperDefContext>(i);
}


size_t LogicFileParser::LogicDefContext::getRuleIndex() const {
  return LogicFileParser::RuleLogicDef;
}


std::any LogicFileParser::LogicDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLogicDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::LogicDefContext* LogicFileParser::logicDef() {
  LogicDefContext *_localctx = _tracker.createInstance<LogicDefContext>(_ctx, getState());
  enterRule(_localctx, 54, LogicFileParser::RuleLogicDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(587);
    match(LogicFileParser::LogicPrefix);
    setState(589);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(588);
      match(LogicFileParser::Colon);
    }
    setState(594);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(591);
      match(LogicFileParser::EOL);
      setState(596);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(597);
    match(LogicFileParser::OBkt);
    setState(601);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(598);
      match(LogicFileParser::EOL);
      setState(603);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(614); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(607);
      _errHandler->sync(this);
      switch (_input->LA(1)) {
        case LogicFileParser::RegionDefPrefix: {
          setState(604);
          regionDef();
          break;
        }

        case LogicFileParser::ItemDefPrefix: {
          setState(605);
          itemDef();
          break;
        }

        case LogicFileParser::HelperPrefix: {
          setState(606);
          helperDef();
          break;
        }

      default:
        throw NoViableAltException(this);
      }
      setState(610); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(609);
        match(LogicFileParser::EOL);
        setState(612); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LogicFileParser::EOL);
      setState(616); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (((((_la - 59) & ~ 0x3fULL) == 0) &&
      ((1ULL << (_la - 59)) & 65601) != 0));
    setState(618);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionsDefContext ------------------------------------------------------------------

LogicFileParser::OptionsDefContext::OptionsDefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionsDefContext::OptionsDefPrefix() {
  return getToken(LogicFileParser::OptionsDefPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionsDefContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionsDefContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionsDefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionsDefContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::OptionsDefContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<LogicFileParser::OptionDefStringsContext *> LogicFileParser::OptionsDefContext::optionDefStrings() {
  return getRuleContexts<LogicFileParser::OptionDefStringsContext>();
}

LogicFileParser::OptionDefStringsContext* LogicFileParser::OptionsDefContext::optionDefStrings(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefStringsContext>(i);
}

std::vector<LogicFileParser::OptionDefIntRangeContext *> LogicFileParser::OptionsDefContext::optionDefIntRange() {
  return getRuleContexts<LogicFileParser::OptionDefIntRangeContext>();
}

LogicFileParser::OptionDefIntRangeContext* LogicFileParser::OptionsDefContext::optionDefIntRange(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefIntRangeContext>(i);
}

std::vector<LogicFileParser::OptionDefIntListContext *> LogicFileParser::OptionsDefContext::optionDefIntList() {
  return getRuleContexts<LogicFileParser::OptionDefIntListContext>();
}

LogicFileParser::OptionDefIntListContext* LogicFileParser::OptionsDefContext::optionDefIntList(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefIntListContext>(i);
}

std::vector<LogicFileParser::OptionDefFloatRangeContext *> LogicFileParser::OptionsDefContext::optionDefFloatRange() {
  return getRuleContexts<LogicFileParser::OptionDefFloatRangeContext>();
}

LogicFileParser::OptionDefFloatRangeContext* LogicFileParser::OptionsDefContext::optionDefFloatRange(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefFloatRangeContext>(i);
}

std::vector<LogicFileParser::OptionDefFloatListContext *> LogicFileParser::OptionsDefContext::optionDefFloatList() {
  return getRuleContexts<LogicFileParser::OptionDefFloatListContext>();
}

LogicFileParser::OptionDefFloatListContext* LogicFileParser::OptionsDefContext::optionDefFloatList(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefFloatListContext>(i);
}

std::vector<LogicFileParser::OptionDefIntContext *> LogicFileParser::OptionsDefContext::optionDefInt() {
  return getRuleContexts<LogicFileParser::OptionDefIntContext>();
}

LogicFileParser::OptionDefIntContext* LogicFileParser::OptionsDefContext::optionDefInt(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefIntContext>(i);
}

std::vector<LogicFileParser::OptionDefFloatContext *> LogicFileParser::OptionsDefContext::optionDefFloat() {
  return getRuleContexts<LogicFileParser::OptionDefFloatContext>();
}

LogicFileParser::OptionDefFloatContext* LogicFileParser::OptionsDefContext::optionDefFloat(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefFloatContext>(i);
}

std::vector<LogicFileParser::OptionDefStringContext *> LogicFileParser::OptionsDefContext::optionDefString() {
  return getRuleContexts<LogicFileParser::OptionDefStringContext>();
}

LogicFileParser::OptionDefStringContext* LogicFileParser::OptionsDefContext::optionDefString(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefStringContext>(i);
}

std::vector<LogicFileParser::OptionDefBoolContext *> LogicFileParser::OptionsDefContext::optionDefBool() {
  return getRuleContexts<LogicFileParser::OptionDefBoolContext>();
}

LogicFileParser::OptionDefBoolContext* LogicFileParser::OptionsDefContext::optionDefBool(size_t i) {
  return getRuleContext<LogicFileParser::OptionDefBoolContext>(i);
}


size_t LogicFileParser::OptionsDefContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionsDef;
}


std::any LogicFileParser::OptionsDefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionsDef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionsDefContext* LogicFileParser::optionsDef() {
  OptionsDefContext *_localctx = _tracker.createInstance<OptionsDefContext>(_ctx, getState());
  enterRule(_localctx, 56, LogicFileParser::RuleOptionsDef);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(620);
    match(LogicFileParser::OptionsDefPrefix);
    setState(622);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(621);
      match(LogicFileParser::Colon);
    }
    setState(627);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(624);
      match(LogicFileParser::EOL);
      setState(629);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(630);
    match(LogicFileParser::OBkt);
    setState(634);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(631);
      match(LogicFileParser::EOL);
      setState(636);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(653); 
    _errHandler->sync(this);
    _la = _input->LA(1);
    do {
      setState(646);
      _errHandler->sync(this);
      switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 81, _ctx)) {
      case 1: {
        setState(637);
        optionDefStrings();
        break;
      }

      case 2: {
        setState(638);
        optionDefIntRange();
        break;
      }

      case 3: {
        setState(639);
        optionDefIntList();
        break;
      }

      case 4: {
        setState(640);
        optionDefFloatRange();
        break;
      }

      case 5: {
        setState(641);
        optionDefFloatList();
        break;
      }

      case 6: {
        setState(642);
        optionDefInt();
        break;
      }

      case 7: {
        setState(643);
        optionDefFloat();
        break;
      }

      case 8: {
        setState(644);
        optionDefString();
        break;
      }

      case 9: {
        setState(645);
        optionDefBool();
        break;
      }

      default:
        break;
      }
      setState(649); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(648);
        match(LogicFileParser::EOL);
        setState(651); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LogicFileParser::EOL);
      setState(655); 
      _errHandler->sync(this);
      _la = _input->LA(1);
    } while (_la == LogicFileParser::OptionPrefix);
    setState(657);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefStringsContext ------------------------------------------------------------------

LogicFileParser::OptionDefStringsContext::OptionDefStringsContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::StringsPrefix() {
  return getToken(LogicFileParser::StringsPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefStringsContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefStringsContext::EscapedString() {
  return getTokens(LogicFileParser::EscapedString);
}

tree::TerminalNode* LogicFileParser::OptionDefStringsContext::EscapedString(size_t i) {
  return getToken(LogicFileParser::EscapedString, i);
}

std::vector<LogicFileParser::ListSeparatorContext *> LogicFileParser::OptionDefStringsContext::listSeparator() {
  return getRuleContexts<LogicFileParser::ListSeparatorContext>();
}

LogicFileParser::ListSeparatorContext* LogicFileParser::OptionDefStringsContext::listSeparator(size_t i) {
  return getRuleContext<LogicFileParser::ListSeparatorContext>(i);
}


size_t LogicFileParser::OptionDefStringsContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefStrings;
}


std::any LogicFileParser::OptionDefStringsContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefStrings(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefStringsContext* LogicFileParser::optionDefStrings() {
  OptionDefStringsContext *_localctx = _tracker.createInstance<OptionDefStringsContext>(_ctx, getState());
  enterRule(_localctx, 58, LogicFileParser::RuleOptionDefStrings);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(659);
    match(LogicFileParser::OptionPrefix);
    setState(660);
    match(LogicFileParser::StringsPrefix);
    setState(661);
    match(LogicFileParser::Ident);
    setState(663);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(662);
      match(LogicFileParser::Colon);
    }
    setState(668);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(665);
      match(LogicFileParser::EOL);
      setState(670);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(671);
    match(LogicFileParser::OBkt);
    setState(675);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(672);
        match(LogicFileParser::EOL); 
      }
      setState(677);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 86, _ctx);
    }
    setState(687);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::EscapedString) {
      setState(678);
      match(LogicFileParser::EscapedString);
      setState(684);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(679);
          listSeparator();
          setState(680);
          match(LogicFileParser::EscapedString); 
        }
        setState(686);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 87, _ctx);
      }
    }
    setState(692);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(689);
      match(LogicFileParser::EOL);
      setState(694);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(695);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefStringContext ------------------------------------------------------------------

LogicFileParser::OptionDefStringContext::OptionDefStringContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefStringContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefStringContext::StringPrefix() {
  return getToken(LogicFileParser::StringPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefStringContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::OptionDefStringContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefString;
}


std::any LogicFileParser::OptionDefStringContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefString(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefStringContext* LogicFileParser::optionDefString() {
  OptionDefStringContext *_localctx = _tracker.createInstance<OptionDefStringContext>(_ctx, getState());
  enterRule(_localctx, 60, LogicFileParser::RuleOptionDefString);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(697);
    match(LogicFileParser::OptionPrefix);
    setState(698);
    match(LogicFileParser::StringPrefix);
    setState(699);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefIntListContext ------------------------------------------------------------------

LogicFileParser::OptionDefIntListContext::OptionDefIntListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::IntsPrefix() {
  return getToken(LogicFileParser::IntsPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefIntListContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefIntListContext::SignedInt() {
  return getTokens(LogicFileParser::SignedInt);
}

tree::TerminalNode* LogicFileParser::OptionDefIntListContext::SignedInt(size_t i) {
  return getToken(LogicFileParser::SignedInt, i);
}

LogicFileParser::ListSeparatorContext* LogicFileParser::OptionDefIntListContext::listSeparator() {
  return getRuleContext<LogicFileParser::ListSeparatorContext>(0);
}


size_t LogicFileParser::OptionDefIntListContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefIntList;
}


std::any LogicFileParser::OptionDefIntListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefIntList(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefIntListContext* LogicFileParser::optionDefIntList() {
  OptionDefIntListContext *_localctx = _tracker.createInstance<OptionDefIntListContext>(_ctx, getState());
  enterRule(_localctx, 62, LogicFileParser::RuleOptionDefIntList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(701);
    match(LogicFileParser::OptionPrefix);
    setState(702);
    match(LogicFileParser::IntsPrefix);
    setState(703);
    match(LogicFileParser::Ident);
    setState(705);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(704);
      match(LogicFileParser::Colon);
    }
    setState(710);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(707);
      match(LogicFileParser::EOL);
      setState(712);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(713);
    match(LogicFileParser::OBkt);
    setState(717);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(714);
        match(LogicFileParser::EOL); 
      }
      setState(719);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 92, _ctx);
    }
    setState(724);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::SignedInt) {
      setState(720);
      match(LogicFileParser::SignedInt);

      setState(721);
      listSeparator();
      setState(722);
      match(LogicFileParser::SignedInt);
    }
    setState(729);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(726);
      match(LogicFileParser::EOL);
      setState(731);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(732);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefIntRangeContext ------------------------------------------------------------------

LogicFileParser::OptionDefIntRangeContext::OptionDefIntRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::IntsPrefix() {
  return getToken(LogicFileParser::IntsPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::MinKW() {
  return getToken(LogicFileParser::MinKW, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefIntRangeContext::Colon() {
  return getTokens(LogicFileParser::Colon);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::Colon(size_t i) {
  return getToken(LogicFileParser::Colon, i);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefIntRangeContext::SignedInt() {
  return getTokens(LogicFileParser::SignedInt);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::SignedInt(size_t i) {
  return getToken(LogicFileParser::SignedInt, i);
}

LogicFileParser::ListSeparatorContext* LogicFileParser::OptionDefIntRangeContext::listSeparator() {
  return getRuleContext<LogicFileParser::ListSeparatorContext>(0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::MaxKW() {
  return getToken(LogicFileParser::MaxKW, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefIntRangeContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::OptionDefIntRangeContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::OptionDefIntRangeContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefIntRange;
}


std::any LogicFileParser::OptionDefIntRangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefIntRange(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefIntRangeContext* LogicFileParser::optionDefIntRange() {
  OptionDefIntRangeContext *_localctx = _tracker.createInstance<OptionDefIntRangeContext>(_ctx, getState());
  enterRule(_localctx, 64, LogicFileParser::RuleOptionDefIntRange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(734);
    match(LogicFileParser::OptionPrefix);
    setState(735);
    match(LogicFileParser::IntsPrefix);
    setState(736);
    match(LogicFileParser::Ident);
    setState(738);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(737);
      match(LogicFileParser::Colon);
    }
    setState(743);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(740);
      match(LogicFileParser::EOL);
      setState(745);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(746);
    match(LogicFileParser::OBkt);
    setState(750);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(747);
      match(LogicFileParser::EOL);
      setState(752);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(753);
    match(LogicFileParser::MinKW);
    setState(754);
    match(LogicFileParser::Colon);
    setState(755);
    match(LogicFileParser::SignedInt);
    setState(756);
    listSeparator();
    setState(757);
    match(LogicFileParser::MaxKW);
    setState(758);
    match(LogicFileParser::Colon);
    setState(759);
    match(LogicFileParser::SignedInt);
    setState(763);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(760);
      match(LogicFileParser::EOL);
      setState(765);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(766);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefIntContext ------------------------------------------------------------------

LogicFileParser::OptionDefIntContext::OptionDefIntContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefIntContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntContext::IntPrefix() {
  return getToken(LogicFileParser::IntPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefIntContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::OptionDefIntContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefInt;
}


std::any LogicFileParser::OptionDefIntContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefInt(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefIntContext* LogicFileParser::optionDefInt() {
  OptionDefIntContext *_localctx = _tracker.createInstance<OptionDefIntContext>(_ctx, getState());
  enterRule(_localctx, 66, LogicFileParser::RuleOptionDefInt);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(768);
    match(LogicFileParser::OptionPrefix);
    setState(769);
    match(LogicFileParser::IntPrefix);
    setState(770);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefFloatListContext ------------------------------------------------------------------

LogicFileParser::OptionDefFloatListContext::OptionDefFloatListContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::FloatsPrefix() {
  return getToken(LogicFileParser::FloatsPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefFloatListContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefFloatListContext::SignedNumber() {
  return getTokens(LogicFileParser::SignedNumber);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatListContext::SignedNumber(size_t i) {
  return getToken(LogicFileParser::SignedNumber, i);
}

std::vector<LogicFileParser::ListSeparatorContext *> LogicFileParser::OptionDefFloatListContext::listSeparator() {
  return getRuleContexts<LogicFileParser::ListSeparatorContext>();
}

LogicFileParser::ListSeparatorContext* LogicFileParser::OptionDefFloatListContext::listSeparator(size_t i) {
  return getRuleContext<LogicFileParser::ListSeparatorContext>(i);
}


size_t LogicFileParser::OptionDefFloatListContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefFloatList;
}


std::any LogicFileParser::OptionDefFloatListContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefFloatList(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefFloatListContext* LogicFileParser::optionDefFloatList() {
  OptionDefFloatListContext *_localctx = _tracker.createInstance<OptionDefFloatListContext>(_ctx, getState());
  enterRule(_localctx, 68, LogicFileParser::RuleOptionDefFloatList);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(772);
    match(LogicFileParser::OptionPrefix);
    setState(773);
    match(LogicFileParser::FloatsPrefix);
    setState(774);
    match(LogicFileParser::Ident);
    setState(776);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(775);
      match(LogicFileParser::Colon);
    }
    setState(781);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(778);
      match(LogicFileParser::EOL);
      setState(783);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(784);
    match(LogicFileParser::OBkt);
    setState(788);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        setState(785);
        match(LogicFileParser::EOL); 
      }
      setState(790);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 101, _ctx);
    }
    setState(800);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::SignedNumber) {
      setState(791);
      match(LogicFileParser::SignedNumber);
      setState(797);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx);
      while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
        if (alt == 1) {
          setState(792);
          listSeparator();
          setState(793);
          match(LogicFileParser::SignedNumber); 
        }
        setState(799);
        _errHandler->sync(this);
        alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 102, _ctx);
      }
    }
    setState(805);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(802);
      match(LogicFileParser::EOL);
      setState(807);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(808);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefFloatRangeContext ------------------------------------------------------------------

LogicFileParser::OptionDefFloatRangeContext::OptionDefFloatRangeContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::FloatsPrefix() {
  return getToken(LogicFileParser::FloatsPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::OBkt() {
  return getToken(LogicFileParser::OBkt, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::MinKW() {
  return getToken(LogicFileParser::MinKW, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefFloatRangeContext::Colon() {
  return getTokens(LogicFileParser::Colon);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::Colon(size_t i) {
  return getToken(LogicFileParser::Colon, i);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefFloatRangeContext::SignedNumber() {
  return getTokens(LogicFileParser::SignedNumber);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::SignedNumber(size_t i) {
  return getToken(LogicFileParser::SignedNumber, i);
}

LogicFileParser::ListSeparatorContext* LogicFileParser::OptionDefFloatRangeContext::listSeparator() {
  return getRuleContext<LogicFileParser::ListSeparatorContext>(0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::MaxKW() {
  return getToken(LogicFileParser::MaxKW, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::CBkt() {
  return getToken(LogicFileParser::CBkt, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefFloatRangeContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatRangeContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::OptionDefFloatRangeContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefFloatRange;
}


std::any LogicFileParser::OptionDefFloatRangeContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefFloatRange(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefFloatRangeContext* LogicFileParser::optionDefFloatRange() {
  OptionDefFloatRangeContext *_localctx = _tracker.createInstance<OptionDefFloatRangeContext>(_ctx, getState());
  enterRule(_localctx, 70, LogicFileParser::RuleOptionDefFloatRange);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(810);
    match(LogicFileParser::OptionPrefix);
    setState(811);
    match(LogicFileParser::FloatsPrefix);
    setState(812);
    match(LogicFileParser::Ident);
    setState(814);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Colon) {
      setState(813);
      match(LogicFileParser::Colon);
    }
    setState(819);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(816);
      match(LogicFileParser::EOL);
      setState(821);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(822);
    match(LogicFileParser::OBkt);
    setState(826);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(823);
      match(LogicFileParser::EOL);
      setState(828);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(829);
    match(LogicFileParser::MinKW);
    setState(830);
    match(LogicFileParser::Colon);
    setState(831);
    match(LogicFileParser::SignedNumber);
    setState(832);
    listSeparator();
    setState(833);
    match(LogicFileParser::MaxKW);
    setState(834);
    match(LogicFileParser::Colon);
    setState(835);
    match(LogicFileParser::SignedNumber);
    setState(836);
    match(LogicFileParser::CBkt);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefFloatContext ------------------------------------------------------------------

LogicFileParser::OptionDefFloatContext::OptionDefFloatContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefFloatContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatContext::FloatPrefix() {
  return getToken(LogicFileParser::FloatPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatContext::SignedNumber() {
  return getToken(LogicFileParser::SignedNumber, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::OptionDefFloatContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::OptionDefFloatContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::OptionDefFloatContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefFloat;
}


std::any LogicFileParser::OptionDefFloatContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefFloat(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefFloatContext* LogicFileParser::optionDefFloat() {
  OptionDefFloatContext *_localctx = _tracker.createInstance<OptionDefFloatContext>(_ctx, getState());
  enterRule(_localctx, 72, LogicFileParser::RuleOptionDefFloat);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(838);
    match(LogicFileParser::OptionPrefix);
    setState(839);
    match(LogicFileParser::FloatPrefix);
    setState(840);
    match(LogicFileParser::Ident);
    setState(841);
    match(LogicFileParser::Colon);
    setState(845);
    _errHandler->sync(this);
    _la = _input->LA(1);
    while (_la == LogicFileParser::EOL) {
      setState(842);
      match(LogicFileParser::EOL);
      setState(847);
      _errHandler->sync(this);
      _la = _input->LA(1);
    }
    setState(848);
    match(LogicFileParser::SignedNumber);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionDefBoolContext ------------------------------------------------------------------

LogicFileParser::OptionDefBoolContext::OptionDefBoolContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionDefBoolContext::OptionPrefix() {
  return getToken(LogicFileParser::OptionPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefBoolContext::BoolPrefix() {
  return getToken(LogicFileParser::BoolPrefix, 0);
}

tree::TerminalNode* LogicFileParser::OptionDefBoolContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::OptionDefBoolContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionDefBool;
}


std::any LogicFileParser::OptionDefBoolContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionDefBool(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionDefBoolContext* LogicFileParser::optionDefBool() {
  OptionDefBoolContext *_localctx = _tracker.createInstance<OptionDefBoolContext>(_ctx, getState());
  enterRule(_localctx, 74, LogicFileParser::RuleOptionDefBool);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(850);
    match(LogicFileParser::OptionPrefix);
    setState(851);
    match(LogicFileParser::BoolPrefix);
    setState(852);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ExprContext ------------------------------------------------------------------

LogicFileParser::ExprContext::ExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}


size_t LogicFileParser::ExprContext::getRuleIndex() const {
  return LogicFileParser::RuleExpr;
}

void LogicFileParser::ExprContext::copyFrom(ExprContext *ctx) {
  ParserRuleContext::copyFrom(ctx);
}

//----------------- SubOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::SubOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::SubOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::SubOperatorContext::SubSymbol() {
  return getToken(LogicFileParser::SubSymbol, 0);
}

LogicFileParser::SubOperatorContext::SubOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::SubOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitSubOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LeftShiftOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::LeftShiftOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::LeftShiftOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::LeftShiftOperatorContext::LSSymbol() {
  return getToken(LogicFileParser::LSSymbol, 0);
}

LogicFileParser::LeftShiftOperatorContext::LeftShiftOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::LeftShiftOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLeftShiftOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- GeqOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::GeqOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::GeqOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::GeqOperatorContext::GeqSymbol() {
  return getToken(LogicFileParser::GeqSymbol, 0);
}

LogicFileParser::GeqOperatorContext::GeqOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::GeqOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitGeqOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- EqOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::EqOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::EqOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::EqOperatorContext::EqSymbol() {
  return getToken(LogicFileParser::EqSymbol, 0);
}

LogicFileParser::EqOperatorContext::EqOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::EqOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEqOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- GrOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::GrOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::GrOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::GrOperatorContext::GrSymbol() {
  return getToken(LogicFileParser::GrSymbol, 0);
}

LogicFileParser::GrOperatorContext::GrOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::GrOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitGrOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- BaseFuncContext ------------------------------------------------------------------

LogicFileParser::BasefuncContext* LogicFileParser::BaseFuncContext::basefunc() {
  return getRuleContext<LogicFileParser::BasefuncContext>(0);
}

LogicFileParser::BaseFuncContext::BaseFuncContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::BaseFuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitBaseFunc(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NeqOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::NeqOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::NeqOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::NeqOperatorContext::NeqSymbol() {
  return getToken(LogicFileParser::NeqSymbol, 0);
}

LogicFileParser::NeqOperatorContext::NeqOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::NeqOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitNeqOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LineSkipContext ------------------------------------------------------------------

tree::TerminalNode* LogicFileParser::LineSkipContext::EOL() {
  return getToken(LogicFileParser::EOL, 0);
}

LogicFileParser::ExprContext* LogicFileParser::LineSkipContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

LogicFileParser::LineSkipContext::LineSkipContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::LineSkipContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLineSkip(this);
  else
    return visitor->visitChildren(this);
}
//----------------- TernaryOperatorContext ------------------------------------------------------------------

tree::TerminalNode* LogicFileParser::TernaryOperatorContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}

std::vector<LogicFileParser::ExprContext *> LogicFileParser::TernaryOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::TernaryOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::TernaryOperatorContext::Question() {
  return getToken(LogicFileParser::Question, 0);
}

LogicFileParser::TernaryOperatorContext::TernaryOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::TernaryOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitTernaryOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AndOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::AndOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::AndOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::AndOperatorContext::AndSymbol() {
  return getToken(LogicFileParser::AndSymbol, 0);
}

LogicFileParser::AndOperatorContext::AndOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::AndOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitAndOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- DivOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::DivOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::DivOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::DivOperatorContext::DivSymbol() {
  return getToken(LogicFileParser::DivSymbol, 0);
}

LogicFileParser::DivOperatorContext::DivOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::DivOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitDivOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- OrOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::OrOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::OrOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::OrOperatorContext::OrSymbol() {
  return getToken(LogicFileParser::OrSymbol, 0);
}

LogicFileParser::OrOperatorContext::OrOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::OrOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOrOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- AddOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::AddOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::AddOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::AddOperatorContext::AddSymbol() {
  return getToken(LogicFileParser::AddSymbol, 0);
}

LogicFileParser::AddOperatorContext::AddOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::AddOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitAddOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LeqOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::LeqOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::LeqOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::LeqOperatorContext::LeqSymbol() {
  return getToken(LogicFileParser::LeqSymbol, 0);
}

LogicFileParser::LeqOperatorContext::LeqOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::LeqOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLeqOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- NotOperatorContext ------------------------------------------------------------------

LogicFileParser::ExprContext* LogicFileParser::NotOperatorContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::NotOperatorContext::NotSymbol() {
  return getToken(LogicFileParser::NotSymbol, 0);
}

LogicFileParser::NotOperatorContext::NotOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::NotOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitNotOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- RightShiftOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::RightShiftOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::RightShiftOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::RightShiftOperatorContext::RSSymbol() {
  return getToken(LogicFileParser::RSSymbol, 0);
}

LogicFileParser::RightShiftOperatorContext::RightShiftOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::RightShiftOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitRightShiftOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- MulOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::MulOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::MulOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::MulOperatorContext::MulSymbol() {
  return getToken(LogicFileParser::MulSymbol, 0);
}

LogicFileParser::MulOperatorContext::MulOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::MulOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitMulOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- LeOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::LeOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::LeOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::LeOperatorContext::LeSymbol() {
  return getToken(LogicFileParser::LeSymbol, 0);
}

LogicFileParser::LeOperatorContext::LeOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::LeOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLeOperator(this);
  else
    return visitor->visitChildren(this);
}
//----------------- ModOperatorContext ------------------------------------------------------------------

std::vector<LogicFileParser::ExprContext *> LogicFileParser::ModOperatorContext::expr() {
  return getRuleContexts<LogicFileParser::ExprContext>();
}

LogicFileParser::ExprContext* LogicFileParser::ModOperatorContext::expr(size_t i) {
  return getRuleContext<LogicFileParser::ExprContext>(i);
}

tree::TerminalNode* LogicFileParser::ModOperatorContext::ModSymbol() {
  return getToken(LogicFileParser::ModSymbol, 0);
}

LogicFileParser::ModOperatorContext::ModOperatorContext(ExprContext *ctx) { copyFrom(ctx); }


std::any LogicFileParser::ModOperatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitModOperator(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ExprContext* LogicFileParser::expr() {
   return expr(0);
}

LogicFileParser::ExprContext* LogicFileParser::expr(int precedence) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  LogicFileParser::ExprContext *_localctx = _tracker.createInstance<ExprContext>(_ctx, parentState);
  LogicFileParser::ExprContext *previousContext = _localctx;
  (void)previousContext; // Silence compiler, in case the context is not used by generated code.
  size_t startState = 76;
  enterRecursionRule(_localctx, 76, LogicFileParser::RuleExpr, precedence);

    

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    unrollRecursionContexts(parentContext);
  });
  try {
    size_t alt;
    enterOuterAlt(_localctx, 1);
    setState(860);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LogicFileParser::Bool:
      case LogicFileParser::SignedNumber:
      case LogicFileParser::EscapedString:
      case LogicFileParser::OPar:
      case LogicFileParser::OptionCheckKW:
      case LogicFileParser::HelperCallKW:
      case LogicFileParser::ArgCheckKW:
      case LogicFileParser::LogicValCheckKW:
      case LogicFileParser::EventCheckKW:
      case LogicFileParser::CanReachLocKW:
      case LogicFileParser::CanReachEntranceKW:
      case LogicFileParser::CanReachRegionKW:
      case LogicFileParser::HasItemKW:
      case LogicFileParser::CountItemKW:
      case LogicFileParser::IsMQDungeonKW:
      case LogicFileParser::FloorKW:
      case LogicFileParser::CeilKW:
      case LogicFileParser::EntranceRefKW:
      case LogicFileParser::RegionRefKW:
      case LogicFileParser::LocRefKW:
      case LogicFileParser::ItemRefKW:
      case LogicFileParser::IfPrefix:
      case LogicFileParser::SwitchPrefix:
      case LogicFileParser::Ident: {
        _localctx = _tracker.createInstance<BaseFuncContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;

        setState(855);
        basefunc();
        break;
      }

      case LogicFileParser::EOL: {
        _localctx = _tracker.createInstance<LineSkipContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(856);
        match(LogicFileParser::EOL);
        setState(857);
        expr(18);
        break;
      }

      case LogicFileParser::NotSymbol: {
        _localctx = _tracker.createInstance<NotOperatorContext>(_localctx);
        _ctx = _localctx;
        previousContext = _localctx;
        setState(858);
        antlrcpp::downCast<NotOperatorContext *>(_localctx)->prefix = match(LogicFileParser::NotSymbol);
        setState(859);
        expr(17);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
    _ctx->stop = _input->LT(-1);
    setState(915);
    _errHandler->sync(this);
    alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
    while (alt != 2 && alt != atn::ATN::INVALID_ALT_NUMBER) {
      if (alt == 1) {
        if (!_parseListeners.empty())
          triggerExitRuleEvent();
        previousContext = _localctx;
        setState(913);
        _errHandler->sync(this);
        switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 110, _ctx)) {
        case 1: {
          auto newContext = _tracker.createInstance<MulOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(862);

          if (!(precpred(_ctx, 16))) throw FailedPredicateException(this, "precpred(_ctx, 16)");
          setState(863);
          antlrcpp::downCast<MulOperatorContext *>(_localctx)->op = match(LogicFileParser::MulSymbol);
          setState(864);
          antlrcpp::downCast<MulOperatorContext *>(_localctx)->right = expr(17);
          break;
        }

        case 2: {
          auto newContext = _tracker.createInstance<DivOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(865);

          if (!(precpred(_ctx, 15))) throw FailedPredicateException(this, "precpred(_ctx, 15)");
          setState(866);
          antlrcpp::downCast<DivOperatorContext *>(_localctx)->op = match(LogicFileParser::DivSymbol);
          setState(867);
          antlrcpp::downCast<DivOperatorContext *>(_localctx)->right = expr(16);
          break;
        }

        case 3: {
          auto newContext = _tracker.createInstance<ModOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(868);

          if (!(precpred(_ctx, 14))) throw FailedPredicateException(this, "precpred(_ctx, 14)");
          setState(869);
          antlrcpp::downCast<ModOperatorContext *>(_localctx)->op = match(LogicFileParser::ModSymbol);
          setState(870);
          antlrcpp::downCast<ModOperatorContext *>(_localctx)->right = expr(15);
          break;
        }

        case 4: {
          auto newContext = _tracker.createInstance<AddOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(871);

          if (!(precpred(_ctx, 13))) throw FailedPredicateException(this, "precpred(_ctx, 13)");
          setState(872);
          antlrcpp::downCast<AddOperatorContext *>(_localctx)->op = match(LogicFileParser::AddSymbol);
          setState(873);
          antlrcpp::downCast<AddOperatorContext *>(_localctx)->right = expr(14);
          break;
        }

        case 5: {
          auto newContext = _tracker.createInstance<SubOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(874);

          if (!(precpred(_ctx, 12))) throw FailedPredicateException(this, "precpred(_ctx, 12)");
          setState(875);
          antlrcpp::downCast<SubOperatorContext *>(_localctx)->op = match(LogicFileParser::SubSymbol);
          setState(876);
          antlrcpp::downCast<SubOperatorContext *>(_localctx)->right = expr(13);
          break;
        }

        case 6: {
          auto newContext = _tracker.createInstance<LeftShiftOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(877);

          if (!(precpred(_ctx, 11))) throw FailedPredicateException(this, "precpred(_ctx, 11)");
          setState(878);
          antlrcpp::downCast<LeftShiftOperatorContext *>(_localctx)->op = match(LogicFileParser::LSSymbol);
          setState(879);
          antlrcpp::downCast<LeftShiftOperatorContext *>(_localctx)->right = expr(12);
          break;
        }

        case 7: {
          auto newContext = _tracker.createInstance<RightShiftOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(880);

          if (!(precpred(_ctx, 10))) throw FailedPredicateException(this, "precpred(_ctx, 10)");
          setState(881);
          antlrcpp::downCast<RightShiftOperatorContext *>(_localctx)->op = match(LogicFileParser::RSSymbol);
          setState(882);
          antlrcpp::downCast<RightShiftOperatorContext *>(_localctx)->right = expr(11);
          break;
        }

        case 8: {
          auto newContext = _tracker.createInstance<LeOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(883);

          if (!(precpred(_ctx, 9))) throw FailedPredicateException(this, "precpred(_ctx, 9)");
          setState(884);
          antlrcpp::downCast<LeOperatorContext *>(_localctx)->op = match(LogicFileParser::LeSymbol);
          setState(885);
          antlrcpp::downCast<LeOperatorContext *>(_localctx)->right = expr(10);
          break;
        }

        case 9: {
          auto newContext = _tracker.createInstance<GrOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(886);

          if (!(precpred(_ctx, 8))) throw FailedPredicateException(this, "precpred(_ctx, 8)");
          setState(887);
          antlrcpp::downCast<GrOperatorContext *>(_localctx)->op = match(LogicFileParser::GrSymbol);
          setState(888);
          antlrcpp::downCast<GrOperatorContext *>(_localctx)->right = expr(9);
          break;
        }

        case 10: {
          auto newContext = _tracker.createInstance<GeqOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(889);

          if (!(precpred(_ctx, 7))) throw FailedPredicateException(this, "precpred(_ctx, 7)");
          setState(890);
          antlrcpp::downCast<GeqOperatorContext *>(_localctx)->op = match(LogicFileParser::GeqSymbol);
          setState(891);
          antlrcpp::downCast<GeqOperatorContext *>(_localctx)->right = expr(8);
          break;
        }

        case 11: {
          auto newContext = _tracker.createInstance<LeqOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(892);

          if (!(precpred(_ctx, 6))) throw FailedPredicateException(this, "precpred(_ctx, 6)");
          setState(893);
          antlrcpp::downCast<LeqOperatorContext *>(_localctx)->op = match(LogicFileParser::LeqSymbol);
          setState(894);
          antlrcpp::downCast<LeqOperatorContext *>(_localctx)->right = expr(7);
          break;
        }

        case 12: {
          auto newContext = _tracker.createInstance<NeqOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(895);

          if (!(precpred(_ctx, 5))) throw FailedPredicateException(this, "precpred(_ctx, 5)");
          setState(896);
          antlrcpp::downCast<NeqOperatorContext *>(_localctx)->op = match(LogicFileParser::NeqSymbol);
          setState(897);
          antlrcpp::downCast<NeqOperatorContext *>(_localctx)->right = expr(6);
          break;
        }

        case 13: {
          auto newContext = _tracker.createInstance<EqOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(898);

          if (!(precpred(_ctx, 4))) throw FailedPredicateException(this, "precpred(_ctx, 4)");
          setState(899);
          antlrcpp::downCast<EqOperatorContext *>(_localctx)->op = match(LogicFileParser::EqSymbol);
          setState(900);
          antlrcpp::downCast<EqOperatorContext *>(_localctx)->right = expr(5);
          break;
        }

        case 14: {
          auto newContext = _tracker.createInstance<OrOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(901);

          if (!(precpred(_ctx, 3))) throw FailedPredicateException(this, "precpred(_ctx, 3)");
          setState(902);
          antlrcpp::downCast<OrOperatorContext *>(_localctx)->op = match(LogicFileParser::OrSymbol);
          setState(903);
          antlrcpp::downCast<OrOperatorContext *>(_localctx)->right = expr(4);
          break;
        }

        case 15: {
          auto newContext = _tracker.createInstance<AndOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(904);

          if (!(precpred(_ctx, 2))) throw FailedPredicateException(this, "precpred(_ctx, 2)");
          setState(905);
          antlrcpp::downCast<AndOperatorContext *>(_localctx)->op = match(LogicFileParser::AndSymbol);
          setState(906);
          antlrcpp::downCast<AndOperatorContext *>(_localctx)->right = expr(3);
          break;
        }

        case 16: {
          auto newContext = _tracker.createInstance<TernaryOperatorContext>(_tracker.createInstance<ExprContext>(parentContext, parentState));
          _localctx = newContext;
          newContext->left = previousContext;
          pushNewRecursionContext(newContext, startState, RuleExpr);
          setState(907);

          if (!(precpred(_ctx, 1))) throw FailedPredicateException(this, "precpred(_ctx, 1)");
          setState(908);
          antlrcpp::downCast<TernaryOperatorContext *>(_localctx)->op = match(LogicFileParser::Question);
          setState(909);
          antlrcpp::downCast<TernaryOperatorContext *>(_localctx)->right = expr(0);
          setState(910);
          match(LogicFileParser::Colon);
          setState(911);
          expr(1);
          break;
        }

        default:
          break;
        } 
      }
      setState(917);
      _errHandler->sync(this);
      alt = getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 111, _ctx);
    }
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}

//----------------- BasefuncContext ------------------------------------------------------------------

LogicFileParser::BasefuncContext::BasefuncContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LogicFileParser::OptionCheckContext* LogicFileParser::BasefuncContext::optionCheck() {
  return getRuleContext<LogicFileParser::OptionCheckContext>(0);
}

LogicFileParser::HelperCallContext* LogicFileParser::BasefuncContext::helperCall() {
  return getRuleContext<LogicFileParser::HelperCallContext>(0);
}

LogicFileParser::ArgCheckContext* LogicFileParser::BasefuncContext::argCheck() {
  return getRuleContext<LogicFileParser::ArgCheckContext>(0);
}

LogicFileParser::LogicValCheckContext* LogicFileParser::BasefuncContext::logicValCheck() {
  return getRuleContext<LogicFileParser::LogicValCheckContext>(0);
}

LogicFileParser::EventCheckContext* LogicFileParser::BasefuncContext::eventCheck() {
  return getRuleContext<LogicFileParser::EventCheckContext>(0);
}

LogicFileParser::CanReachLocCallContext* LogicFileParser::BasefuncContext::canReachLocCall() {
  return getRuleContext<LogicFileParser::CanReachLocCallContext>(0);
}

LogicFileParser::CanReachEntranceCallContext* LogicFileParser::BasefuncContext::canReachEntranceCall() {
  return getRuleContext<LogicFileParser::CanReachEntranceCallContext>(0);
}

LogicFileParser::CanReachRegionCallContext* LogicFileParser::BasefuncContext::canReachRegionCall() {
  return getRuleContext<LogicFileParser::CanReachRegionCallContext>(0);
}

LogicFileParser::HasItemCallContext* LogicFileParser::BasefuncContext::hasItemCall() {
  return getRuleContext<LogicFileParser::HasItemCallContext>(0);
}

LogicFileParser::CountItemCallContext* LogicFileParser::BasefuncContext::countItemCall() {
  return getRuleContext<LogicFileParser::CountItemCallContext>(0);
}

LogicFileParser::IsDungeonMqCallContext* LogicFileParser::BasefuncContext::isDungeonMqCall() {
  return getRuleContext<LogicFileParser::IsDungeonMqCallContext>(0);
}

LogicFileParser::FloorCallContext* LogicFileParser::BasefuncContext::floorCall() {
  return getRuleContext<LogicFileParser::FloorCallContext>(0);
}

LogicFileParser::CeilCallContext* LogicFileParser::BasefuncContext::ceilCall() {
  return getRuleContext<LogicFileParser::CeilCallContext>(0);
}

LogicFileParser::SwitchExprContext* LogicFileParser::BasefuncContext::switchExpr() {
  return getRuleContext<LogicFileParser::SwitchExprContext>(0);
}

LogicFileParser::IfBlockContext* LogicFileParser::BasefuncContext::ifBlock() {
  return getRuleContext<LogicFileParser::IfBlockContext>(0);
}

LogicFileParser::ValueContext* LogicFileParser::BasefuncContext::value() {
  return getRuleContext<LogicFileParser::ValueContext>(0);
}


size_t LogicFileParser::BasefuncContext::getRuleIndex() const {
  return LogicFileParser::RuleBasefunc;
}


std::any LogicFileParser::BasefuncContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitBasefunc(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::BasefuncContext* LogicFileParser::basefunc() {
  BasefuncContext *_localctx = _tracker.createInstance<BasefuncContext>(_ctx, getState());
  enterRule(_localctx, 78, LogicFileParser::RuleBasefunc);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(934);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LogicFileParser::OptionCheckKW: {
        enterOuterAlt(_localctx, 1);
        setState(918);
        optionCheck();
        break;
      }

      case LogicFileParser::HelperCallKW: {
        enterOuterAlt(_localctx, 2);
        setState(919);
        helperCall();
        break;
      }

      case LogicFileParser::ArgCheckKW: {
        enterOuterAlt(_localctx, 3);
        setState(920);
        argCheck();
        break;
      }

      case LogicFileParser::LogicValCheckKW: {
        enterOuterAlt(_localctx, 4);
        setState(921);
        logicValCheck();
        break;
      }

      case LogicFileParser::EventCheckKW: {
        enterOuterAlt(_localctx, 5);
        setState(922);
        eventCheck();
        break;
      }

      case LogicFileParser::CanReachLocKW: {
        enterOuterAlt(_localctx, 6);
        setState(923);
        canReachLocCall();
        break;
      }

      case LogicFileParser::CanReachEntranceKW: {
        enterOuterAlt(_localctx, 7);
        setState(924);
        canReachEntranceCall();
        break;
      }

      case LogicFileParser::CanReachRegionKW: {
        enterOuterAlt(_localctx, 8);
        setState(925);
        canReachRegionCall();
        break;
      }

      case LogicFileParser::HasItemKW: {
        enterOuterAlt(_localctx, 9);
        setState(926);
        hasItemCall();
        break;
      }

      case LogicFileParser::CountItemKW: {
        enterOuterAlt(_localctx, 10);
        setState(927);
        countItemCall();
        break;
      }

      case LogicFileParser::IsMQDungeonKW: {
        enterOuterAlt(_localctx, 11);
        setState(928);
        isDungeonMqCall();
        break;
      }

      case LogicFileParser::FloorKW: {
        enterOuterAlt(_localctx, 12);
        setState(929);
        floorCall();
        break;
      }

      case LogicFileParser::CeilKW: {
        enterOuterAlt(_localctx, 13);
        setState(930);
        ceilCall();
        break;
      }

      case LogicFileParser::SwitchPrefix: {
        enterOuterAlt(_localctx, 14);
        setState(931);
        switchExpr();
        break;
      }

      case LogicFileParser::IfPrefix: {
        enterOuterAlt(_localctx, 15);
        setState(932);
        ifBlock();
        break;
      }

      case LogicFileParser::Bool:
      case LogicFileParser::SignedNumber:
      case LogicFileParser::EscapedString:
      case LogicFileParser::OPar:
      case LogicFileParser::EntranceRefKW:
      case LogicFileParser::RegionRefKW:
      case LogicFileParser::LocRefKW:
      case LogicFileParser::ItemRefKW:
      case LogicFileParser::Ident: {
        enterOuterAlt(_localctx, 16);
        setState(933);
        value();
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Arg_passContext ------------------------------------------------------------------

LogicFileParser::Arg_passContext::Arg_passContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LogicFileParser::ExprContext* LogicFileParser::Arg_passContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

std::vector<tree::TerminalNode *> LogicFileParser::Arg_passContext::Ident() {
  return getTokens(LogicFileParser::Ident);
}

tree::TerminalNode* LogicFileParser::Arg_passContext::Ident(size_t i) {
  return getToken(LogicFileParser::Ident, i);
}

tree::TerminalNode* LogicFileParser::Arg_passContext::ArgAssign() {
  return getToken(LogicFileParser::ArgAssign, 0);
}


size_t LogicFileParser::Arg_passContext::getRuleIndex() const {
  return LogicFileParser::RuleArg_pass;
}


std::any LogicFileParser::Arg_passContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitArg_pass(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::Arg_passContext* LogicFileParser::arg_pass() {
  Arg_passContext *_localctx = _tracker.createInstance<Arg_passContext>(_ctx, getState());
  enterRule(_localctx, 80, LogicFileParser::RuleArg_pass);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(938);
    _errHandler->sync(this);

    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 113, _ctx)) {
    case 1: {
      setState(936);
      match(LogicFileParser::Ident);
      setState(937);
      match(LogicFileParser::ArgAssign);
      break;
    }

    default:
      break;
    }
    setState(942);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 114, _ctx)) {
    case 1: {
      setState(940);
      expr(0);
      break;
    }

    case 2: {
      setState(941);
      match(LogicFileParser::Ident);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- Args_passContext ------------------------------------------------------------------

LogicFileParser::Args_passContext::Args_passContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<LogicFileParser::Arg_passContext *> LogicFileParser::Args_passContext::arg_pass() {
  return getRuleContexts<LogicFileParser::Arg_passContext>();
}

LogicFileParser::Arg_passContext* LogicFileParser::Args_passContext::arg_pass(size_t i) {
  return getRuleContext<LogicFileParser::Arg_passContext>(i);
}

std::vector<tree::TerminalNode *> LogicFileParser::Args_passContext::Comma() {
  return getTokens(LogicFileParser::Comma);
}

tree::TerminalNode* LogicFileParser::Args_passContext::Comma(size_t i) {
  return getToken(LogicFileParser::Comma, i);
}


size_t LogicFileParser::Args_passContext::getRuleIndex() const {
  return LogicFileParser::RuleArgs_pass;
}


std::any LogicFileParser::Args_passContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitArgs_pass(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::Args_passContext* LogicFileParser::args_pass() {
  Args_passContext *_localctx = _tracker.createInstance<Args_passContext>(_ctx, getState());
  enterRule(_localctx, 82, LogicFileParser::RuleArgs_pass);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(952);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if ((((_la & ~ 0x3fULL) == 0) &&
      ((1ULL << _la) & 155374178554415272) != 0) || _la == LogicFileParser::Ident) {
      setState(944);
      arg_pass();
      setState(949);
      _errHandler->sync(this);
      _la = _input->LA(1);
      while (_la == LogicFileParser::Comma) {
        setState(945);
        match(LogicFileParser::Comma);
        setState(946);
        arg_pass();
        setState(951);
        _errHandler->sync(this);
        _la = _input->LA(1);
      }
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- OptionCheckContext ------------------------------------------------------------------

LogicFileParser::OptionCheckContext::OptionCheckContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::OptionCheckContext::OptionCheckKW() {
  return getToken(LogicFileParser::OptionCheckKW, 0);
}

tree::TerminalNode* LogicFileParser::OptionCheckContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::OptionCheckContext::getRuleIndex() const {
  return LogicFileParser::RuleOptionCheck;
}


std::any LogicFileParser::OptionCheckContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitOptionCheck(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::OptionCheckContext* LogicFileParser::optionCheck() {
  OptionCheckContext *_localctx = _tracker.createInstance<OptionCheckContext>(_ctx, getState());
  enterRule(_localctx, 84, LogicFileParser::RuleOptionCheck);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(954);
    match(LogicFileParser::OptionCheckKW);
    setState(955);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HelperCallContext ------------------------------------------------------------------

LogicFileParser::HelperCallContext::HelperCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::HelperCallContext::HelperCallKW() {
  return getToken(LogicFileParser::HelperCallKW, 0);
}

tree::TerminalNode* LogicFileParser::HelperCallContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::HelperCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

LogicFileParser::Args_passContext* LogicFileParser::HelperCallContext::args_pass() {
  return getRuleContext<LogicFileParser::Args_passContext>(0);
}

tree::TerminalNode* LogicFileParser::HelperCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}


size_t LogicFileParser::HelperCallContext::getRuleIndex() const {
  return LogicFileParser::RuleHelperCall;
}


std::any LogicFileParser::HelperCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitHelperCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::HelperCallContext* LogicFileParser::helperCall() {
  HelperCallContext *_localctx = _tracker.createInstance<HelperCallContext>(_ctx, getState());
  enterRule(_localctx, 86, LogicFileParser::RuleHelperCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(957);
    match(LogicFileParser::HelperCallKW);
    setState(958);
    match(LogicFileParser::Ident);
    setState(959);
    match(LogicFileParser::OPar);
    setState(960);
    args_pass();
    setState(961);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ArgCheckContext ------------------------------------------------------------------

LogicFileParser::ArgCheckContext::ArgCheckContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ArgCheckContext::ArgCheckKW() {
  return getToken(LogicFileParser::ArgCheckKW, 0);
}

tree::TerminalNode* LogicFileParser::ArgCheckContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::ArgCheckContext::getRuleIndex() const {
  return LogicFileParser::RuleArgCheck;
}


std::any LogicFileParser::ArgCheckContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitArgCheck(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ArgCheckContext* LogicFileParser::argCheck() {
  ArgCheckContext *_localctx = _tracker.createInstance<ArgCheckContext>(_ctx, getState());
  enterRule(_localctx, 88, LogicFileParser::RuleArgCheck);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(963);
    match(LogicFileParser::ArgCheckKW);
    setState(964);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LogicValCheckContext ------------------------------------------------------------------

LogicFileParser::LogicValCheckContext::LogicValCheckContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::LogicValCheckContext::LogicValCheckKW() {
  return getToken(LogicFileParser::LogicValCheckKW, 0);
}

tree::TerminalNode* LogicFileParser::LogicValCheckContext::Dot() {
  return getToken(LogicFileParser::Dot, 0);
}

tree::TerminalNode* LogicFileParser::LogicValCheckContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::LogicValCheckContext::getRuleIndex() const {
  return LogicFileParser::RuleLogicValCheck;
}


std::any LogicFileParser::LogicValCheckContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLogicValCheck(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::LogicValCheckContext* LogicFileParser::logicValCheck() {
  LogicValCheckContext *_localctx = _tracker.createInstance<LogicValCheckContext>(_ctx, getState());
  enterRule(_localctx, 90, LogicFileParser::RuleLogicValCheck);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(966);
    match(LogicFileParser::LogicValCheckKW);
    setState(967);
    match(LogicFileParser::Dot);
    setState(968);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EventCheckContext ------------------------------------------------------------------

LogicFileParser::EventCheckContext::EventCheckContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::EventCheckContext::EventCheckKW() {
  return getToken(LogicFileParser::EventCheckKW, 0);
}

tree::TerminalNode* LogicFileParser::EventCheckContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::EventCheckContext::getRuleIndex() const {
  return LogicFileParser::RuleEventCheck;
}


std::any LogicFileParser::EventCheckContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEventCheck(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::EventCheckContext* LogicFileParser::eventCheck() {
  EventCheckContext *_localctx = _tracker.createInstance<EventCheckContext>(_ctx, getState());
  enterRule(_localctx, 92, LogicFileParser::RuleEventCheck);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(970);
    match(LogicFileParser::EventCheckKW);
    setState(971);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CanReachLocCallContext ------------------------------------------------------------------

LogicFileParser::CanReachLocCallContext::CanReachLocCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::CanReachLocCallContext::CanReachLocKW() {
  return getToken(LogicFileParser::CanReachLocKW, 0);
}

tree::TerminalNode* LogicFileParser::CanReachLocCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

tree::TerminalNode* LogicFileParser::CanReachLocCallContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::CanReachLocCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}

tree::TerminalNode* LogicFileParser::CanReachLocCallContext::Comma() {
  return getToken(LogicFileParser::Comma, 0);
}

tree::TerminalNode* LogicFileParser::CanReachLocCallContext::Age() {
  return getToken(LogicFileParser::Age, 0);
}


size_t LogicFileParser::CanReachLocCallContext::getRuleIndex() const {
  return LogicFileParser::RuleCanReachLocCall;
}


std::any LogicFileParser::CanReachLocCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitCanReachLocCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::CanReachLocCallContext* LogicFileParser::canReachLocCall() {
  CanReachLocCallContext *_localctx = _tracker.createInstance<CanReachLocCallContext>(_ctx, getState());
  enterRule(_localctx, 94, LogicFileParser::RuleCanReachLocCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(973);
    match(LogicFileParser::CanReachLocKW);
    setState(974);
    match(LogicFileParser::OPar);
    setState(975);
    match(LogicFileParser::Ident);
    setState(978);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Comma) {
      setState(976);
      match(LogicFileParser::Comma);
      setState(977);
      match(LogicFileParser::Age);
    }
    setState(980);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CanReachEntranceCallContext ------------------------------------------------------------------

LogicFileParser::CanReachEntranceCallContext::CanReachEntranceCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::CanReachEntranceCallContext::CanReachEntranceKW() {
  return getToken(LogicFileParser::CanReachEntranceKW, 0);
}

tree::TerminalNode* LogicFileParser::CanReachEntranceCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

tree::TerminalNode* LogicFileParser::CanReachEntranceCallContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::CanReachEntranceCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}

tree::TerminalNode* LogicFileParser::CanReachEntranceCallContext::Comma() {
  return getToken(LogicFileParser::Comma, 0);
}

tree::TerminalNode* LogicFileParser::CanReachEntranceCallContext::Age() {
  return getToken(LogicFileParser::Age, 0);
}


size_t LogicFileParser::CanReachEntranceCallContext::getRuleIndex() const {
  return LogicFileParser::RuleCanReachEntranceCall;
}


std::any LogicFileParser::CanReachEntranceCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitCanReachEntranceCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::CanReachEntranceCallContext* LogicFileParser::canReachEntranceCall() {
  CanReachEntranceCallContext *_localctx = _tracker.createInstance<CanReachEntranceCallContext>(_ctx, getState());
  enterRule(_localctx, 96, LogicFileParser::RuleCanReachEntranceCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(982);
    match(LogicFileParser::CanReachEntranceKW);
    setState(983);
    match(LogicFileParser::OPar);
    setState(984);
    match(LogicFileParser::Ident);
    setState(987);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Comma) {
      setState(985);
      match(LogicFileParser::Comma);
      setState(986);
      match(LogicFileParser::Age);
    }
    setState(989);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CanReachRegionCallContext ------------------------------------------------------------------

LogicFileParser::CanReachRegionCallContext::CanReachRegionCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::CanReachRegionCallContext::CanReachRegionKW() {
  return getToken(LogicFileParser::CanReachRegionKW, 0);
}

tree::TerminalNode* LogicFileParser::CanReachRegionCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

tree::TerminalNode* LogicFileParser::CanReachRegionCallContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::CanReachRegionCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}

tree::TerminalNode* LogicFileParser::CanReachRegionCallContext::Comma() {
  return getToken(LogicFileParser::Comma, 0);
}

tree::TerminalNode* LogicFileParser::CanReachRegionCallContext::Age() {
  return getToken(LogicFileParser::Age, 0);
}


size_t LogicFileParser::CanReachRegionCallContext::getRuleIndex() const {
  return LogicFileParser::RuleCanReachRegionCall;
}


std::any LogicFileParser::CanReachRegionCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitCanReachRegionCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::CanReachRegionCallContext* LogicFileParser::canReachRegionCall() {
  CanReachRegionCallContext *_localctx = _tracker.createInstance<CanReachRegionCallContext>(_ctx, getState());
  enterRule(_localctx, 98, LogicFileParser::RuleCanReachRegionCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(991);
    match(LogicFileParser::CanReachRegionKW);
    setState(992);
    match(LogicFileParser::OPar);
    setState(993);
    match(LogicFileParser::Ident);
    setState(996);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Comma) {
      setState(994);
      match(LogicFileParser::Comma);
      setState(995);
      match(LogicFileParser::Age);
    }
    setState(998);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- HasItemCallContext ------------------------------------------------------------------

LogicFileParser::HasItemCallContext::HasItemCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::HasItemCallContext::HasItemKW() {
  return getToken(LogicFileParser::HasItemKW, 0);
}

tree::TerminalNode* LogicFileParser::HasItemCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

tree::TerminalNode* LogicFileParser::HasItemCallContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::HasItemCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}

tree::TerminalNode* LogicFileParser::HasItemCallContext::Comma() {
  return getToken(LogicFileParser::Comma, 0);
}

LogicFileParser::ExprContext* LogicFileParser::HasItemCallContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}


size_t LogicFileParser::HasItemCallContext::getRuleIndex() const {
  return LogicFileParser::RuleHasItemCall;
}


std::any LogicFileParser::HasItemCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitHasItemCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::HasItemCallContext* LogicFileParser::hasItemCall() {
  HasItemCallContext *_localctx = _tracker.createInstance<HasItemCallContext>(_ctx, getState());
  enterRule(_localctx, 100, LogicFileParser::RuleHasItemCall);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1000);
    match(LogicFileParser::HasItemKW);
    setState(1001);
    match(LogicFileParser::OPar);
    setState(1002);
    match(LogicFileParser::Ident);
    setState(1005);
    _errHandler->sync(this);

    _la = _input->LA(1);
    if (_la == LogicFileParser::Comma) {
      setState(1003);
      match(LogicFileParser::Comma);
      setState(1004);
      expr(0);
    }
    setState(1007);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CountItemCallContext ------------------------------------------------------------------

LogicFileParser::CountItemCallContext::CountItemCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::CountItemCallContext::CountItemKW() {
  return getToken(LogicFileParser::CountItemKW, 0);
}

tree::TerminalNode* LogicFileParser::CountItemCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

tree::TerminalNode* LogicFileParser::CountItemCallContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::CountItemCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}


size_t LogicFileParser::CountItemCallContext::getRuleIndex() const {
  return LogicFileParser::RuleCountItemCall;
}


std::any LogicFileParser::CountItemCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitCountItemCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::CountItemCallContext* LogicFileParser::countItemCall() {
  CountItemCallContext *_localctx = _tracker.createInstance<CountItemCallContext>(_ctx, getState());
  enterRule(_localctx, 102, LogicFileParser::RuleCountItemCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1009);
    match(LogicFileParser::CountItemKW);
    setState(1010);
    match(LogicFileParser::OPar);
    setState(1011);
    match(LogicFileParser::Ident);
    setState(1012);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- IsDungeonMqCallContext ------------------------------------------------------------------

LogicFileParser::IsDungeonMqCallContext::IsDungeonMqCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::IsDungeonMqCallContext::IsMQDungeonKW() {
  return getToken(LogicFileParser::IsMQDungeonKW, 0);
}

tree::TerminalNode* LogicFileParser::IsDungeonMqCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

tree::TerminalNode* LogicFileParser::IsDungeonMqCallContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}

tree::TerminalNode* LogicFileParser::IsDungeonMqCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}


size_t LogicFileParser::IsDungeonMqCallContext::getRuleIndex() const {
  return LogicFileParser::RuleIsDungeonMqCall;
}


std::any LogicFileParser::IsDungeonMqCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitIsDungeonMqCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::IsDungeonMqCallContext* LogicFileParser::isDungeonMqCall() {
  IsDungeonMqCallContext *_localctx = _tracker.createInstance<IsDungeonMqCallContext>(_ctx, getState());
  enterRule(_localctx, 104, LogicFileParser::RuleIsDungeonMqCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1014);
    match(LogicFileParser::IsMQDungeonKW);
    setState(1015);
    match(LogicFileParser::OPar);
    setState(1016);
    match(LogicFileParser::Ident);
    setState(1017);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- FloorCallContext ------------------------------------------------------------------

LogicFileParser::FloorCallContext::FloorCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::FloorCallContext::FloorKW() {
  return getToken(LogicFileParser::FloorKW, 0);
}

tree::TerminalNode* LogicFileParser::FloorCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

LogicFileParser::ExprContext* LogicFileParser::FloorCallContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::FloorCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}


size_t LogicFileParser::FloorCallContext::getRuleIndex() const {
  return LogicFileParser::RuleFloorCall;
}


std::any LogicFileParser::FloorCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitFloorCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::FloorCallContext* LogicFileParser::floorCall() {
  FloorCallContext *_localctx = _tracker.createInstance<FloorCallContext>(_ctx, getState());
  enterRule(_localctx, 106, LogicFileParser::RuleFloorCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1019);
    match(LogicFileParser::FloorKW);
    setState(1020);
    match(LogicFileParser::OPar);
    setState(1021);
    expr(0);
    setState(1022);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- CeilCallContext ------------------------------------------------------------------

LogicFileParser::CeilCallContext::CeilCallContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::CeilCallContext::CeilKW() {
  return getToken(LogicFileParser::CeilKW, 0);
}

tree::TerminalNode* LogicFileParser::CeilCallContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

LogicFileParser::ExprContext* LogicFileParser::CeilCallContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::CeilCallContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}


size_t LogicFileParser::CeilCallContext::getRuleIndex() const {
  return LogicFileParser::RuleCeilCall;
}


std::any LogicFileParser::CeilCallContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitCeilCall(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::CeilCallContext* LogicFileParser::ceilCall() {
  CeilCallContext *_localctx = _tracker.createInstance<CeilCallContext>(_ctx, getState());
  enterRule(_localctx, 108, LogicFileParser::RuleCeilCall);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1024);
    match(LogicFileParser::CeilKW);
    setState(1025);
    match(LogicFileParser::OPar);
    setState(1026);
    expr(0);
    setState(1027);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ValueContext ------------------------------------------------------------------

LogicFileParser::ValueContext::ValueContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

LogicFileParser::ParenExprContext* LogicFileParser::ValueContext::parenExpr() {
  return getRuleContext<LogicFileParser::ParenExprContext>(0);
}

tree::TerminalNode* LogicFileParser::ValueContext::Bool() {
  return getToken(LogicFileParser::Bool, 0);
}

tree::TerminalNode* LogicFileParser::ValueContext::SignedNumber() {
  return getToken(LogicFileParser::SignedNumber, 0);
}

LogicFileParser::EnumValueRefContext* LogicFileParser::ValueContext::enumValueRef() {
  return getRuleContext<LogicFileParser::EnumValueRefContext>(0);
}

LogicFileParser::EntranceRefContext* LogicFileParser::ValueContext::entranceRef() {
  return getRuleContext<LogicFileParser::EntranceRefContext>(0);
}

LogicFileParser::RegionRefContext* LogicFileParser::ValueContext::regionRef() {
  return getRuleContext<LogicFileParser::RegionRefContext>(0);
}

LogicFileParser::LocRefContext* LogicFileParser::ValueContext::locRef() {
  return getRuleContext<LogicFileParser::LocRefContext>(0);
}

LogicFileParser::ItemRefContext* LogicFileParser::ValueContext::itemRef() {
  return getRuleContext<LogicFileParser::ItemRefContext>(0);
}

tree::TerminalNode* LogicFileParser::ValueContext::EscapedString() {
  return getToken(LogicFileParser::EscapedString, 0);
}


size_t LogicFileParser::ValueContext::getRuleIndex() const {
  return LogicFileParser::RuleValue;
}


std::any LogicFileParser::ValueContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitValue(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ValueContext* LogicFileParser::value() {
  ValueContext *_localctx = _tracker.createInstance<ValueContext>(_ctx, getState());
  enterRule(_localctx, 110, LogicFileParser::RuleValue);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1038);
    _errHandler->sync(this);
    switch (_input->LA(1)) {
      case LogicFileParser::OPar: {
        enterOuterAlt(_localctx, 1);
        setState(1029);
        parenExpr();
        break;
      }

      case LogicFileParser::Bool: {
        enterOuterAlt(_localctx, 2);
        setState(1030);
        match(LogicFileParser::Bool);
        break;
      }

      case LogicFileParser::SignedNumber: {
        enterOuterAlt(_localctx, 3);
        setState(1031);
        match(LogicFileParser::SignedNumber);
        break;
      }

      case LogicFileParser::Ident: {
        enterOuterAlt(_localctx, 4);
        setState(1032);
        enumValueRef();
        break;
      }

      case LogicFileParser::EntranceRefKW: {
        enterOuterAlt(_localctx, 5);
        setState(1033);
        entranceRef();
        break;
      }

      case LogicFileParser::RegionRefKW: {
        enterOuterAlt(_localctx, 6);
        setState(1034);
        regionRef();
        break;
      }

      case LogicFileParser::LocRefKW: {
        enterOuterAlt(_localctx, 7);
        setState(1035);
        locRef();
        break;
      }

      case LogicFileParser::ItemRefKW: {
        enterOuterAlt(_localctx, 8);
        setState(1036);
        itemRef();
        break;
      }

      case LogicFileParser::EscapedString: {
        enterOuterAlt(_localctx, 9);
        setState(1037);
        match(LogicFileParser::EscapedString);
        break;
      }

    default:
      throw NoViableAltException(this);
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ParenExprContext ------------------------------------------------------------------

LogicFileParser::ParenExprContext::ParenExprContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ParenExprContext::OPar() {
  return getToken(LogicFileParser::OPar, 0);
}

LogicFileParser::ExprContext* LogicFileParser::ParenExprContext::expr() {
  return getRuleContext<LogicFileParser::ExprContext>(0);
}

tree::TerminalNode* LogicFileParser::ParenExprContext::CPar() {
  return getToken(LogicFileParser::CPar, 0);
}


size_t LogicFileParser::ParenExprContext::getRuleIndex() const {
  return LogicFileParser::RuleParenExpr;
}


std::any LogicFileParser::ParenExprContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitParenExpr(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ParenExprContext* LogicFileParser::parenExpr() {
  ParenExprContext *_localctx = _tracker.createInstance<ParenExprContext>(_ctx, getState());
  enterRule(_localctx, 112, LogicFileParser::RuleParenExpr);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1040);
    match(LogicFileParser::OPar);
    setState(1041);
    expr(0);
    setState(1042);
    match(LogicFileParser::CPar);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EnumValueRefContext ------------------------------------------------------------------

LogicFileParser::EnumValueRefContext::EnumValueRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

std::vector<tree::TerminalNode *> LogicFileParser::EnumValueRefContext::Ident() {
  return getTokens(LogicFileParser::Ident);
}

tree::TerminalNode* LogicFileParser::EnumValueRefContext::Ident(size_t i) {
  return getToken(LogicFileParser::Ident, i);
}

tree::TerminalNode* LogicFileParser::EnumValueRefContext::Colon() {
  return getToken(LogicFileParser::Colon, 0);
}


size_t LogicFileParser::EnumValueRefContext::getRuleIndex() const {
  return LogicFileParser::RuleEnumValueRef;
}


std::any LogicFileParser::EnumValueRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEnumValueRef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::EnumValueRefContext* LogicFileParser::enumValueRef() {
  EnumValueRefContext *_localctx = _tracker.createInstance<EnumValueRefContext>(_ctx, getState());
  enterRule(_localctx, 114, LogicFileParser::RuleEnumValueRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1044);
    match(LogicFileParser::Ident);
    setState(1045);
    match(LogicFileParser::Colon);
    setState(1046);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- EntranceRefContext ------------------------------------------------------------------

LogicFileParser::EntranceRefContext::EntranceRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::EntranceRefContext::EntranceRefKW() {
  return getToken(LogicFileParser::EntranceRefKW, 0);
}

tree::TerminalNode* LogicFileParser::EntranceRefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::EntranceRefContext::getRuleIndex() const {
  return LogicFileParser::RuleEntranceRef;
}


std::any LogicFileParser::EntranceRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitEntranceRef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::EntranceRefContext* LogicFileParser::entranceRef() {
  EntranceRefContext *_localctx = _tracker.createInstance<EntranceRefContext>(_ctx, getState());
  enterRule(_localctx, 116, LogicFileParser::RuleEntranceRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1048);
    match(LogicFileParser::EntranceRefKW);
    setState(1049);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- RegionRefContext ------------------------------------------------------------------

LogicFileParser::RegionRefContext::RegionRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::RegionRefContext::RegionRefKW() {
  return getToken(LogicFileParser::RegionRefKW, 0);
}

tree::TerminalNode* LogicFileParser::RegionRefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::RegionRefContext::getRuleIndex() const {
  return LogicFileParser::RuleRegionRef;
}


std::any LogicFileParser::RegionRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitRegionRef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::RegionRefContext* LogicFileParser::regionRef() {
  RegionRefContext *_localctx = _tracker.createInstance<RegionRefContext>(_ctx, getState());
  enterRule(_localctx, 118, LogicFileParser::RuleRegionRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1051);
    match(LogicFileParser::RegionRefKW);
    setState(1052);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- LocRefContext ------------------------------------------------------------------

LogicFileParser::LocRefContext::LocRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::LocRefContext::LocRefKW() {
  return getToken(LogicFileParser::LocRefKW, 0);
}

tree::TerminalNode* LogicFileParser::LocRefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::LocRefContext::getRuleIndex() const {
  return LogicFileParser::RuleLocRef;
}


std::any LogicFileParser::LocRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitLocRef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::LocRefContext* LogicFileParser::locRef() {
  LocRefContext *_localctx = _tracker.createInstance<LocRefContext>(_ctx, getState());
  enterRule(_localctx, 120, LogicFileParser::RuleLocRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1054);
    match(LogicFileParser::LocRefKW);
    setState(1055);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ItemRefContext ------------------------------------------------------------------

LogicFileParser::ItemRefContext::ItemRefContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ItemRefContext::ItemRefKW() {
  return getToken(LogicFileParser::ItemRefKW, 0);
}

tree::TerminalNode* LogicFileParser::ItemRefContext::Ident() {
  return getToken(LogicFileParser::Ident, 0);
}


size_t LogicFileParser::ItemRefContext::getRuleIndex() const {
  return LogicFileParser::RuleItemRef;
}


std::any LogicFileParser::ItemRefContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitItemRef(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ItemRefContext* LogicFileParser::itemRef() {
  ItemRefContext *_localctx = _tracker.createInstance<ItemRefContext>(_ctx, getState());
  enterRule(_localctx, 122, LogicFileParser::RuleItemRef);

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    enterOuterAlt(_localctx, 1);
    setState(1057);
    match(LogicFileParser::ItemRefKW);
    setState(1058);
    match(LogicFileParser::Ident);
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

//----------------- ListSeparatorContext ------------------------------------------------------------------

LogicFileParser::ListSeparatorContext::ListSeparatorContext(ParserRuleContext *parent, size_t invokingState)
  : ParserRuleContext(parent, invokingState) {
}

tree::TerminalNode* LogicFileParser::ListSeparatorContext::Comma() {
  return getToken(LogicFileParser::Comma, 0);
}

std::vector<tree::TerminalNode *> LogicFileParser::ListSeparatorContext::EOL() {
  return getTokens(LogicFileParser::EOL);
}

tree::TerminalNode* LogicFileParser::ListSeparatorContext::EOL(size_t i) {
  return getToken(LogicFileParser::EOL, i);
}


size_t LogicFileParser::ListSeparatorContext::getRuleIndex() const {
  return LogicFileParser::RuleListSeparator;
}


std::any LogicFileParser::ListSeparatorContext::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast<LogicFileParserVisitor*>(visitor))
    return parserVisitor->visitListSeparator(this);
  else
    return visitor->visitChildren(this);
}

LogicFileParser::ListSeparatorContext* LogicFileParser::listSeparator() {
  ListSeparatorContext *_localctx = _tracker.createInstance<ListSeparatorContext>(_ctx, getState());
  enterRule(_localctx, 124, LogicFileParser::RuleListSeparator);
  size_t _la = 0;

#if __cplusplus > 201703L
  auto onExit = finally([=, this] {
#else
  auto onExit = finally([=] {
#endif
    exitRule();
  });
  try {
    setState(1069);
    _errHandler->sync(this);
    switch (getInterpreter<atn::ParserATNSimulator>()->adaptivePredict(_input, 124, _ctx)) {
    case 1: {
      enterOuterAlt(_localctx, 1);
      setState(1060);
      match(LogicFileParser::Comma);
      break;
    }

    case 2: {
      enterOuterAlt(_localctx, 2);
      setState(1062);
      _errHandler->sync(this);

      _la = _input->LA(1);
      if (_la == LogicFileParser::Comma) {
        setState(1061);
        match(LogicFileParser::Comma);
      }
      setState(1065); 
      _errHandler->sync(this);
      _la = _input->LA(1);
      do {
        setState(1064);
        match(LogicFileParser::EOL);
        setState(1067); 
        _errHandler->sync(this);
        _la = _input->LA(1);
      } while (_la == LogicFileParser::EOL);
      break;
    }

    default:
      break;
    }
   
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }

  return _localctx;
}

bool LogicFileParser::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    case 38: return exprSempred(antlrcpp::downCast<ExprContext *>(context), predicateIndex);

  default:
    break;
  }
  return true;
}

bool LogicFileParser::exprSempred(ExprContext *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    case 0: return precpred(_ctx, 16);
    case 1: return precpred(_ctx, 15);
    case 2: return precpred(_ctx, 14);
    case 3: return precpred(_ctx, 13);
    case 4: return precpred(_ctx, 12);
    case 5: return precpred(_ctx, 11);
    case 6: return precpred(_ctx, 10);
    case 7: return precpred(_ctx, 9);
    case 8: return precpred(_ctx, 8);
    case 9: return precpred(_ctx, 7);
    case 10: return precpred(_ctx, 6);
    case 11: return precpred(_ctx, 5);
    case 12: return precpred(_ctx, 4);
    case 13: return precpred(_ctx, 3);
    case 14: return precpred(_ctx, 2);
    case 15: return precpred(_ctx, 1);

  default:
    break;
  }
  return true;
}

void LogicFileParser::initialize() {
#if ANTLR4_USE_THREAD_LOCAL_CACHE
  logicfileparserParserInitialize();
#else
  ::antlr4::internal::call_once(logicfileparserParserOnceFlag, logicfileparserParserInitialize);
#endif
}
